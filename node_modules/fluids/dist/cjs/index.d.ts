export { hasFluidValue, getFluidValue, getFluidConfig, setFluidConfig, addFluidObserver, };
/** Does the given value have a `FluidConfig` object? */
declare const hasFluidValue: (arg: any) => arg is FluidValue<any, any>;
/** Get the current value of a fluid object. Returns the first argument when it's not a fluid object. */
declare function getFluidValue<T, U = never>(target: T | FluidValue<U>): Exclude<T, FluidValue> | U;
declare type GetFluidConfig<T> = T extends FluidValue<infer U, infer E> ? FluidConfig<U, E> : FluidConfig | undefined;
/** Get the methods for observing the given object. Returns undefined if not a fluid object. */
declare function getFluidConfig<T>(arg: T): GetFluidConfig<T>;
/** Set the methods for observing the given object. */
declare function setFluidConfig(target: object, config: FluidConfig): void;
/** Add an observer to a fluid object. Returns an unsubscribe function if the target is a fluid object, otherwise undefined. */
declare function addFluidObserver<E extends FluidEvent>(target: FluidValue<any, E>, observer: FluidObserver<E>): () => void;
declare function addFluidObserver(target: object, observer: FluidObserver): (() => void) | undefined;
export interface ChangeEvent<T = any> {
    type: 'change';
    parent: FluidValue<T>;
    value: T;
}
/**
 * An event sent to `FluidObserver` objects.
 */
export interface FluidEvent<T = any> {
    type: string;
    parent: FluidValue<T>;
}
/**
 * Compatibility layer for external data sources.
 */
export interface FluidConfig<T = any, Event extends FluidEvent<T> = any> {
    get(): T;
    addChild(child: FluidObserver<Event>): void;
    removeChild(child: FluidObserver<Event>): void;
}
/**
 * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.
 *
 * In order to support non-writable streams, this class doesn't expect a `set` method to exist.
 *
 * It can send *any* event to observers, not only change events.
 */
export declare abstract class FluidValue<T = any, Event extends FluidEvent<T> = any> implements FluidConfig<T, Event> {
    constructor();
    abstract get(): T;
    abstract addChild(child: FluidObserver<Event>): void;
    abstract removeChild(child: FluidObserver<Event>): void;
}
/**
 * This object can observe any `FluidValue` object that sends compatible events.
 */
export interface FluidObserver<Event extends FluidEvent = any> {
    onParentChange(event: ChangeEvent | Event): void;
}
/**
 * Add the `FluidValue` type to every property.
 */
export declare type FluidProps<T> = T extends object ? {
    [P in keyof T]: T[P] | FluidValue<Exclude<T[P], void>>;
} : unknown;
