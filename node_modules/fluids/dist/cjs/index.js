"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var $config = Symbol.for('FluidValue:config');
/** Does the given value have a `FluidConfig` object? */
var hasFluidValue = function (arg) { return !!getFluidConfig(arg); };
exports.hasFluidValue = hasFluidValue;
function getFluidValue(arg) {
    var config = getFluidConfig(arg);
    return config ? config.get() : arg;
}
exports.getFluidValue = getFluidValue;
function getFluidConfig(arg) {
    if (arg)
        return arg[$config];
}
exports.getFluidConfig = getFluidConfig;
/** Set the methods for observing the given object. */
function setFluidConfig(target, config) {
    Object.defineProperty(target, $config, {
        value: config,
        configurable: true,
    });
}
exports.setFluidConfig = setFluidConfig;
function addFluidObserver(target, observer) {
    var config = getFluidConfig(target);
    if (config) {
        config.addChild(observer);
        return function () { return config.removeChild(observer); };
    }
}
exports.addFluidObserver = addFluidObserver;
/**
 * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.
 *
 * In order to support non-writable streams, this class doesn't expect a `set` method to exist.
 *
 * It can send *any* event to observers, not only change events.
 */
var FluidValue = /** @class */ (function () {
    function FluidValue() {
        setFluidConfig(this, this);
    }
    return FluidValue;
}());
exports.FluidValue = FluidValue;
//# sourceMappingURL=index.js.map