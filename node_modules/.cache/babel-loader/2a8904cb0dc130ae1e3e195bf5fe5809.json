{"ast":null,"code":"import { Face3, Geometry, Vector2, Vector3 } from \"../../../build/three.module.js\";\n/**\n *\tSubdivision Geometry Modifier\n *\t\tusing Loop Subdivision Scheme\n *\n *\tReferences:\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n *\n *\tKnown Issues:\n *\t\t- currently doesn't handle \"Sharp Edges\"\n */\n\nvar SubdivisionModifier = function (subdivisions) {\n  this.subdivisions = subdivisions === undefined ? 1 : subdivisions;\n}; // Applies the \"modify\" pattern\n\n\nSubdivisionModifier.prototype.modify = function (geometry) {\n  if (geometry.isBufferGeometry) {\n    geometry = new Geometry().fromBufferGeometry(geometry);\n  } else {\n    geometry = geometry.clone();\n  }\n\n  geometry.mergeVertices();\n  var repeats = this.subdivisions;\n\n  while (repeats-- > 0) {\n    this.smooth(geometry);\n  }\n\n  geometry.computeFaceNormals();\n  geometry.computeVertexNormals();\n  return geometry;\n};\n\n(function () {\n  // Some constants\n  var ABC = ['a', 'b', 'c'];\n\n  function getEdge(a, b, map) {\n    var vertexIndexA = Math.min(a, b);\n    var vertexIndexB = Math.max(a, b);\n    var key = vertexIndexA + \"_\" + vertexIndexB;\n    return map[key];\n  }\n\n  function processEdge(a, b, vertices, map, face, metaVertices) {\n    var vertexIndexA = Math.min(a, b);\n    var vertexIndexB = Math.max(a, b);\n    var key = vertexIndexA + \"_\" + vertexIndexB;\n    var edge;\n\n    if (key in map) {\n      edge = map[key];\n    } else {\n      var vertexA = vertices[vertexIndexA];\n      var vertexB = vertices[vertexIndexB];\n      edge = {\n        a: vertexA,\n        // pointer reference\n        b: vertexB,\n        newEdge: null,\n        // aIndex: a, // numbered reference\n        // bIndex: b,\n        faces: [] // pointers to face\n\n      };\n      map[key] = edge;\n    }\n\n    edge.faces.push(face);\n    metaVertices[a].edges.push(edge);\n    metaVertices[b].edges.push(edge);\n  }\n\n  function generateLookups(vertices, faces, metaVertices, edges) {\n    var i, il, face;\n\n    for (i = 0, il = vertices.length; i < il; i++) {\n      metaVertices[i] = {\n        edges: []\n      };\n    }\n\n    for (i = 0, il = faces.length; i < il; i++) {\n      face = faces[i];\n      processEdge(face.a, face.b, vertices, edges, face, metaVertices);\n      processEdge(face.b, face.c, vertices, edges, face, metaVertices);\n      processEdge(face.c, face.a, vertices, edges, face, metaVertices);\n    }\n  }\n\n  function newFace(newFaces, a, b, c, materialIndex) {\n    newFaces.push(new Face3(a, b, c, undefined, undefined, materialIndex));\n  }\n\n  function midpoint(a, b) {\n    return Math.abs(b - a) / 2 + Math.min(a, b);\n  }\n\n  function newUv(newUvs, a, b, c) {\n    newUvs.push([a.clone(), b.clone(), c.clone()]);\n  } /////////////////////////////\n  // Performs one iteration of Subdivision\n\n\n  SubdivisionModifier.prototype.smooth = function (geometry) {\n    var tmp = new Vector3();\n    var oldVertices, oldFaces, oldUvs;\n    var newVertices,\n        newFaces,\n        newUVs = [];\n    var n, i, il, j, k;\n    var metaVertices, sourceEdges; // new stuff.\n\n    var sourceEdges, newEdgeVertices, newSourceVertices;\n    oldVertices = geometry.vertices; // { x, y, z}\n\n    oldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\n    oldUvs = geometry.faceVertexUvs;\n    var hasUvs = oldUvs[0] !== undefined && oldUvs[0].length > 0;\n\n    if (hasUvs) {\n      for (var j = 0; j < oldUvs.length; j++) {\n        newUVs.push([]);\n      }\n    }\n    /******************************************************\n     *\n     * Step 0: Preprocess Geometry to Generate edges Lookup\n     *\n     *******************************************************/\n\n\n    metaVertices = new Array(oldVertices.length);\n    sourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n    generateLookups(oldVertices, oldFaces, metaVertices, sourceEdges);\n    /******************************************************\n     *\n     *\tStep 1.\n     *\tFor each edge, create a new Edge Vertex,\n     *\tthen position it.\n     *\n     *******************************************************/\n\n    newEdgeVertices = [];\n    var other, currentEdge, newEdge, face;\n    var edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n    for (i in sourceEdges) {\n      currentEdge = sourceEdges[i];\n      newEdge = new Vector3();\n      edgeVertexWeight = 3 / 8;\n      adjacentVertexWeight = 1 / 8;\n      connectedFaces = currentEdge.faces.length; // check how many linked faces. 2 should be correct.\n\n      if (connectedFaces != 2) {\n        // if length is not 2, handle condition\n        edgeVertexWeight = 0.5;\n        adjacentVertexWeight = 0;\n\n        if (connectedFaces != 1) {// console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n        }\n      }\n\n      newEdge.addVectors(currentEdge.a, currentEdge.b).multiplyScalar(edgeVertexWeight);\n      tmp.set(0, 0, 0);\n\n      for (j = 0; j < connectedFaces; j++) {\n        face = currentEdge.faces[j];\n\n        for (k = 0; k < 3; k++) {\n          other = oldVertices[face[ABC[k]]];\n          if (other !== currentEdge.a && other !== currentEdge.b) break;\n        }\n\n        tmp.add(other);\n      }\n\n      tmp.multiplyScalar(adjacentVertexWeight);\n      newEdge.add(tmp);\n      currentEdge.newEdge = newEdgeVertices.length;\n      newEdgeVertices.push(newEdge); // console.log(currentEdge, newEdge);\n    }\n    /******************************************************\n     *\n     *\tStep 2.\n     *\tReposition each source vertices.\n     *\n     *******************************************************/\n\n\n    var beta, sourceVertexWeight, connectingVertexWeight;\n    var connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n    newSourceVertices = [];\n\n    for (i = 0, il = oldVertices.length; i < il; i++) {\n      oldVertex = oldVertices[i]; // find all connecting edges (using lookupTable)\n\n      connectingEdges = metaVertices[i].edges;\n      n = connectingEdges.length;\n\n      if (n == 3) {\n        beta = 3 / 16;\n      } else if (n > 3) {\n        beta = 3 / (8 * n); // Warren's modified formula\n      } // Loop's original beta formula\n      // beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\n      sourceVertexWeight = 1 - n * beta;\n      connectingVertexWeight = beta;\n\n      if (n <= 2) {\n        // crease and boundary rules\n        // console.warn('crease and boundary rules');\n        if (n == 2) {\n          // console.warn( '2 connecting edges', connectingEdges );\n          sourceVertexWeight = 3 / 4;\n          connectingVertexWeight = 1 / 8; // sourceVertexWeight = 1;\n          // connectingVertexWeight = 0;\n        } else if (n == 1) {// console.warn( 'only 1 connecting edge' );\n        } else if (n == 0) {// console.warn( '0 connecting edges' );\n        }\n      }\n\n      newSourceVertex = oldVertex.clone().multiplyScalar(sourceVertexWeight);\n      tmp.set(0, 0, 0);\n\n      for (j = 0; j < n; j++) {\n        connectingEdge = connectingEdges[j];\n        other = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n        tmp.add(other);\n      }\n\n      tmp.multiplyScalar(connectingVertexWeight);\n      newSourceVertex.add(tmp);\n      newSourceVertices.push(newSourceVertex);\n    }\n    /******************************************************\n     *\n     *\tStep 3.\n     *\tGenerate Faces between source vertices\n     *\tand edge vertices.\n     *\n     *******************************************************/\n\n\n    newVertices = newSourceVertices.concat(newEdgeVertices);\n    var sl = newSourceVertices.length,\n        edge1,\n        edge2,\n        edge3;\n    newFaces = [];\n    var uv, x0, x1, x2;\n    var x3 = new Vector2();\n    var x4 = new Vector2();\n    var x5 = new Vector2();\n\n    for (i = 0, il = oldFaces.length; i < il; i++) {\n      face = oldFaces[i]; // find the 3 new edges vertex of each old face\n\n      edge1 = getEdge(face.a, face.b, sourceEdges).newEdge + sl;\n      edge2 = getEdge(face.b, face.c, sourceEdges).newEdge + sl;\n      edge3 = getEdge(face.c, face.a, sourceEdges).newEdge + sl; // create 4 faces.\n\n      newFace(newFaces, edge1, edge2, edge3, face.materialIndex);\n      newFace(newFaces, face.a, edge1, edge3, face.materialIndex);\n      newFace(newFaces, face.b, edge2, edge1, face.materialIndex);\n      newFace(newFaces, face.c, edge3, edge2, face.materialIndex); // create 4 new uv's\n\n      if (hasUvs) {\n        for (var j = 0; j < oldUvs.length; j++) {\n          uv = oldUvs[j][i];\n          x0 = uv[0];\n          x1 = uv[1];\n          x2 = uv[2];\n          x3.set(midpoint(x0.x, x1.x), midpoint(x0.y, x1.y));\n          x4.set(midpoint(x1.x, x2.x), midpoint(x1.y, x2.y));\n          x5.set(midpoint(x0.x, x2.x), midpoint(x0.y, x2.y));\n          newUv(newUVs[j], x3, x4, x5);\n          newUv(newUVs[j], x0, x3, x5);\n          newUv(newUVs[j], x1, x4, x3);\n          newUv(newUVs[j], x2, x5, x4);\n        }\n      }\n    } // Overwrite old arrays\n\n\n    geometry.vertices = newVertices;\n    geometry.faces = newFaces;\n    if (hasUvs) geometry.faceVertexUvs = newUVs; // console.log('done');\n  };\n})();\n\nexport { SubdivisionModifier };","map":{"version":3,"sources":["/home/rodrigo/Dropbox/Projetos/rodrigoKulb/minecraft-react-game/node_modules/three/examples/jsm/modifiers/SubdivisionModifier.js"],"names":["Face3","Geometry","Vector2","Vector3","SubdivisionModifier","subdivisions","undefined","prototype","modify","geometry","isBufferGeometry","fromBufferGeometry","clone","mergeVertices","repeats","smooth","computeFaceNormals","computeVertexNormals","ABC","getEdge","a","b","map","vertexIndexA","Math","min","vertexIndexB","max","key","processEdge","vertices","face","metaVertices","edge","vertexA","vertexB","newEdge","faces","push","edges","generateLookups","i","il","length","c","newFace","newFaces","materialIndex","midpoint","abs","newUv","newUvs","tmp","oldVertices","oldFaces","oldUvs","newVertices","newUVs","n","j","k","sourceEdges","newEdgeVertices","newSourceVertices","faceVertexUvs","hasUvs","Array","other","currentEdge","edgeVertexWeight","adjacentVertexWeight","connectedFaces","addVectors","multiplyScalar","set","add","beta","sourceVertexWeight","connectingVertexWeight","connectingEdge","connectingEdges","oldVertex","newSourceVertex","concat","sl","edge1","edge2","edge3","uv","x0","x1","x2","x3","x4","x5","x","y"],"mappings":"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","sourcesContent":["import {\n\tFace3,\n\tGeometry,\n\tVector2,\n\tVector3\n} from \"../../../build/three.module.js\";\n/**\n *\tSubdivision Geometry Modifier\n *\t\tusing Loop Subdivision Scheme\n *\n *\tReferences:\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n *\n *\tKnown Issues:\n *\t\t- currently doesn't handle \"Sharp Edges\"\n */\n\nvar SubdivisionModifier = function ( subdivisions ) {\n\n\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\n\n};\n\n// Applies the \"modify\" pattern\nSubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\tif ( geometry.isBufferGeometry ) {\n\n\t\tgeometry = new Geometry().fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry = geometry.clone();\n\n\t}\n\n\tgeometry.mergeVertices();\n\n\tvar repeats = this.subdivisions;\n\n\twhile ( repeats -- > 0 ) {\n\n\t\tthis.smooth( geometry );\n\n\t}\n\n\tgeometry.computeFaceNormals();\n\tgeometry.computeVertexNormals();\n\n\treturn geometry;\n\n};\n\n( function () {\n\n\t// Some constants\n\tvar ABC = [ 'a', 'b', 'c' ];\n\n\n\tfunction getEdge( a, b, map ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\treturn map[ key ];\n\n\t}\n\n\n\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\tvar edge;\n\n\t\tif ( key in map ) {\n\n\t\t\tedge = map[ key ];\n\n\t\t} else {\n\n\t\t\tvar vertexA = vertices[ vertexIndexA ];\n\t\t\tvar vertexB = vertices[ vertexIndexB ];\n\n\t\t\tedge = {\n\n\t\t\t\ta: vertexA, // pointer reference\n\t\t\t\tb: vertexB,\n\t\t\t\tnewEdge: null,\n\t\t\t\t// aIndex: a, // numbered reference\n\t\t\t\t// bIndex: b,\n\t\t\t\tfaces: [] // pointers to face\n\n\t\t\t};\n\n\t\t\tmap[ key ] = edge;\n\n\t\t}\n\n\t\tedge.faces.push( face );\n\n\t\tmetaVertices[ a ].edges.push( edge );\n\t\tmetaVertices[ b ].edges.push( edge );\n\n\n\t}\n\n\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\n\n\t\tvar i, il, face;\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tmetaVertices[ i ] = { edges: [] };\n\n\t\t}\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\n\n\t\t}\n\n\t}\n\n\tfunction newFace( newFaces, a, b, c, materialIndex ) {\n\n\t\tnewFaces.push( new Face3( a, b, c, undefined, undefined, materialIndex ) );\n\n\t}\n\n\tfunction midpoint( a, b ) {\n\n\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\n\n\t}\n\n\tfunction newUv( newUvs, a, b, c ) {\n\n\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\n\n\t}\n\n\t/////////////////////////////\n\n\t// Performs one iteration of Subdivision\n\tSubdivisionModifier.prototype.smooth = function ( geometry ) {\n\n\t\tvar tmp = new Vector3();\n\n\t\tvar oldVertices, oldFaces, oldUvs;\n\t\tvar newVertices, newFaces, newUVs = [];\n\n\t\tvar n, i, il, j, k;\n\t\tvar metaVertices, sourceEdges;\n\n\t\t// new stuff.\n\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\n\n\t\toldVertices = geometry.vertices; // { x, y, z}\n\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\t\toldUvs = geometry.faceVertexUvs;\n\n\t\tvar hasUvs = oldUvs[ 0 ] !== undefined && oldUvs[ 0 ].length > 0;\n\n\t\tif ( hasUvs ) {\n\n\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\tnewUVs.push( [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/******************************************************\n\t\t *\n\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\n\t\t *\n\t\t *******************************************************/\n\n\t\tmetaVertices = new Array( oldVertices.length );\n\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 1.\n\t\t *\tFor each edge, create a new Edge Vertex,\n\t\t *\tthen position it.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewEdgeVertices = [];\n\t\tvar other, currentEdge, newEdge, face;\n\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n\t\tfor ( i in sourceEdges ) {\n\n\t\t\tcurrentEdge = sourceEdges[ i ];\n\t\t\tnewEdge = new Vector3();\n\n\t\t\tedgeVertexWeight = 3 / 8;\n\t\t\tadjacentVertexWeight = 1 / 8;\n\n\t\t\tconnectedFaces = currentEdge.faces.length;\n\n\t\t\t// check how many linked faces. 2 should be correct.\n\t\t\tif ( connectedFaces != 2 ) {\n\n\t\t\t\t// if length is not 2, handle condition\n\t\t\t\tedgeVertexWeight = 0.5;\n\t\t\t\tadjacentVertexWeight = 0;\n\n\t\t\t\tif ( connectedFaces != 1 ) {\n\n\t\t\t\t\t// console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\n\n\t\t\t\tface = currentEdge.faces[ j ];\n\n\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\n\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\n\n\t\t\t\t}\n\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\n\t\t\tnewEdge.add( tmp );\n\n\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\n\t\t\tnewEdgeVertices.push( newEdge );\n\n\t\t\t// console.log(currentEdge, newEdge);\n\n\t\t}\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 2.\n\t\t *\tReposition each source vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\n\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n\t\tnewSourceVertices = [];\n\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\toldVertex = oldVertices[ i ];\n\n\t\t\t// find all connecting edges (using lookupTable)\n\t\t\tconnectingEdges = metaVertices[ i ].edges;\n\t\t\tn = connectingEdges.length;\n\n\t\t\tif ( n == 3 ) {\n\n\t\t\t\tbeta = 3 / 16;\n\n\t\t\t} else if ( n > 3 ) {\n\n\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\n\n\t\t\t}\n\n\t\t\t// Loop's original beta formula\n\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\t\t\tsourceVertexWeight = 1 - n * beta;\n\t\t\tconnectingVertexWeight = beta;\n\n\t\t\tif ( n <= 2 ) {\n\n\t\t\t\t// crease and boundary rules\n\t\t\t\t// console.warn('crease and boundary rules');\n\n\t\t\t\tif ( n == 2 ) {\n\n\t\t\t\t\t// console.warn( '2 connecting edges', connectingEdges );\n\t\t\t\t\tsourceVertexWeight = 3 / 4;\n\t\t\t\t\tconnectingVertexWeight = 1 / 8;\n\n\t\t\t\t\t// sourceVertexWeight = 1;\n\t\t\t\t\t// connectingVertexWeight = 0;\n\n\t\t\t\t} else if ( n == 1 ) {\n\n\t\t\t\t\t// console.warn( 'only 1 connecting edge' );\n\n\t\t\t\t} else if ( n == 0 ) {\n\n\t\t\t\t\t// console.warn( '0 connecting edges' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < n; j ++ ) {\n\n\t\t\t\tconnectingEdge = connectingEdges[ j ];\n\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( connectingVertexWeight );\n\t\t\tnewSourceVertex.add( tmp );\n\n\t\t\tnewSourceVertices.push( newSourceVertex );\n\n\t\t}\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 3.\n\t\t *\tGenerate Faces between source vertices\n\t\t *\tand edge vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\n\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\n\t\tnewFaces = [];\n\n\t\tvar uv, x0, x1, x2;\n\t\tvar x3 = new Vector2();\n\t\tvar x4 = new Vector2();\n\t\tvar x5 = new Vector2();\n\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\tface = oldFaces[ i ];\n\n\t\t\t// find the 3 new edges vertex of each old face\n\n\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\n\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\n\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\n\n\t\t\t// create 4 faces.\n\n\t\t\tnewFace( newFaces, edge1, edge2, edge3, face.materialIndex );\n\t\t\tnewFace( newFaces, face.a, edge1, edge3, face.materialIndex );\n\t\t\tnewFace( newFaces, face.b, edge2, edge1, face.materialIndex );\n\t\t\tnewFace( newFaces, face.c, edge3, edge2, face.materialIndex );\n\n\t\t\t// create 4 new uv's\n\n\t\t\tif ( hasUvs ) {\n\n\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\tuv = oldUvs[ j ][ i ];\n\n\t\t\t\t\tx0 = uv[ 0 ];\n\t\t\t\t\tx1 = uv[ 1 ];\n\t\t\t\t\tx2 = uv[ 2 ];\n\n\t\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\n\t\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\n\t\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\n\n\t\t\t\t\tnewUv( newUVs[ j ], x3, x4, x5 );\n\t\t\t\t\tnewUv( newUVs[ j ], x0, x3, x5 );\n\n\t\t\t\t\tnewUv( newUVs[ j ], x1, x4, x3 );\n\t\t\t\t\tnewUv( newUVs[ j ], x2, x5, x4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Overwrite old arrays\n\t\tgeometry.vertices = newVertices;\n\t\tgeometry.faces = newFaces;\n\t\tif ( hasUvs ) geometry.faceVertexUvs = newUVs;\n\n\t\t// console.log('done');\n\n\t};\n\n} )();\n\nexport { SubdivisionModifier };\n"]},"metadata":{},"sourceType":"module"}