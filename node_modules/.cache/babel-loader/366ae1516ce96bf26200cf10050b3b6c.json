{"ast":null,"code":"import { Color, LinearFilter, MathUtils, Matrix4, Mesh, PerspectiveCamera, Plane, RGBFormat, ShaderMaterial, UniformsUtils, Vector3, Vector4, WebGLRenderTarget } from \"../../../build/three.module.js\";\n\nvar Reflector = function (geometry, options) {\n  Mesh.call(this, geometry);\n  this.type = 'Reflector';\n  var scope = this;\n  options = options || {};\n  var color = options.color !== undefined ? new Color(options.color) : new Color(0x7F7F7F);\n  var textureWidth = options.textureWidth || 512;\n  var textureHeight = options.textureHeight || 512;\n  var clipBias = options.clipBias || 0;\n  var shader = options.shader || Reflector.ReflectorShader; //\n\n  var reflectorPlane = new Plane();\n  var normal = new Vector3();\n  var reflectorWorldPosition = new Vector3();\n  var cameraWorldPosition = new Vector3();\n  var rotationMatrix = new Matrix4();\n  var lookAtPosition = new Vector3(0, 0, -1);\n  var clipPlane = new Vector4();\n  var view = new Vector3();\n  var target = new Vector3();\n  var q = new Vector4();\n  var textureMatrix = new Matrix4();\n  var virtualCamera = new PerspectiveCamera();\n  var parameters = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBFormat\n  };\n  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {\n    renderTarget.texture.generateMipmaps = false;\n  }\n\n  var material = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(shader.uniforms),\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader\n  });\n  material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n  material.uniforms[\"color\"].value = color;\n  material.uniforms[\"textureMatrix\"].value = textureMatrix;\n  this.material = material;\n\n  this.onBeforeRender = function (renderer, scene, camera) {\n    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(reflectorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(reflectorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(reflectorWorldPosition);\n    virtualCamera.position.copy(view);\n    virtualCamera.up.set(0, 1, 0);\n    virtualCamera.up.applyMatrix4(rotationMatrix);\n    virtualCamera.up.reflect(normal);\n    virtualCamera.lookAt(target);\n    virtualCamera.far = camera.far; // Used in WebGLBackground\n\n    virtualCamera.updateMatrixWorld();\n    virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(virtualCamera.projectionMatrix);\n    textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n    var projectionMatrix = virtualCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Render\n\n    renderTarget.texture.encoding = renderer.outputEncoding;\n    scope.visible = false;\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    renderer.xr.enabled = false; // Avoid camera modification\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, virtualCamera);\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n    var viewport = camera.viewport;\n\n    if (viewport !== undefined) {\n      renderer.state.viewport(viewport);\n    }\n\n    scope.visible = true;\n  };\n\n  this.getRenderTarget = function () {\n    return renderTarget;\n  };\n};\n\nReflector.prototype = Object.create(Mesh.prototype);\nReflector.prototype.constructor = Reflector;\nReflector.ReflectorShader = {\n  uniforms: {\n    'color': {\n      value: null\n    },\n    'tDiffuse': {\n      value: null\n    },\n    'textureMatrix': {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\nexport { Reflector };","map":{"version":3,"sources":["/home/rodrigo/Dropbox/Projetos/rodrigoKulb/minecraft-react/node_modules/three/examples/jsm/objects/Reflector.js"],"names":["Color","LinearFilter","MathUtils","Matrix4","Mesh","PerspectiveCamera","Plane","RGBFormat","ShaderMaterial","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","Reflector","geometry","options","call","type","scope","color","undefined","textureWidth","textureHeight","clipBias","shader","ReflectorShader","reflectorPlane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","virtualCamera","parameters","minFilter","magFilter","format","renderTarget","isPowerOfTwo","texture","generateMipmaps","material","uniforms","clone","fragmentShader","vertexShader","value","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","prototype","Object","create","constructor","join"],"mappings":"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","sourcesContent":["import {\n\tColor,\n\tLinearFilter,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tRGBFormat,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\n\nvar Reflector = function ( geometry, options ) {\n\n\tMesh.call( this, geometry );\n\n\tthis.type = 'Reflector';\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar clipBias = options.clipBias || 0;\n\tvar shader = options.shader || Reflector.ReflectorShader;\n\n\t//\n\n\tvar reflectorPlane = new Plane();\n\tvar normal = new Vector3();\n\tvar reflectorWorldPosition = new Vector3();\n\tvar cameraWorldPosition = new Vector3();\n\tvar rotationMatrix = new Matrix4();\n\tvar lookAtPosition = new Vector3( 0, 0, - 1 );\n\tvar clipPlane = new Vector4();\n\n\tvar view = new Vector3();\n\tvar target = new Vector3();\n\tvar q = new Vector4();\n\n\tvar textureMatrix = new Matrix4();\n\tvar virtualCamera = new PerspectiveCamera();\n\n\tvar parameters = {\n\t\tminFilter: LinearFilter,\n\t\tmagFilter: LinearFilter,\n\t\tformat: RGBFormat\n\t};\n\n\tvar renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tif ( ! MathUtils.isPowerOfTwo( textureWidth ) || ! MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t}\n\n\tvar material = new ShaderMaterial( {\n\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\tfragmentShader: shader.fragmentShader,\n\t\tvertexShader: shader.vertexShader\n\t} );\n\n\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\tmaterial.uniforms[ \"color\" ].value = color;\n\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\tthis.material = material;\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\tnormal.set( 0, 0, 1 );\n\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\tview.reflect( normal ).negate();\n\t\tview.add( reflectorWorldPosition );\n\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\ttarget.reflect( normal ).negate();\n\t\ttarget.add( reflectorWorldPosition );\n\n\t\tvirtualCamera.position.copy( view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\tvirtualCamera.up.reflect( normal );\n\t\tvirtualCamera.lookAt( target );\n\n\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Update the texture matrix\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\tq.z = - 1.0;\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t// Render\n\n\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\tscope.visible = false;\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t// Restore viewport\n\n\t\tvar viewport = camera.viewport;\n\n\t\tif ( viewport !== undefined ) {\n\n\t\t\trenderer.state.viewport( viewport );\n\n\t\t}\n\n\t\tscope.visible = true;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn renderTarget;\n\n\t};\n\n};\n\nReflector.prototype = Object.create( Mesh.prototype );\nReflector.prototype.constructor = Reflector;\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: [\n\t\t'uniform mat4 textureMatrix;',\n\t\t'varying vec4 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\t\t'uniform vec3 color;',\n\t\t'uniform sampler2D tDiffuse;',\n\t\t'varying vec4 vUv;',\n\n\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t'}',\n\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t'}',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' )\n};\n\nexport { Reflector };\n"]},"metadata":{},"sourceType":"module"}