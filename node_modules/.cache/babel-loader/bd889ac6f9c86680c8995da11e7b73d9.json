{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { getFluidValue } from 'fluids';\nimport { createInterpolator } from './createInterpolator';\nimport { colorToRgba } from './colorToRgba';\nimport * as G from './globals'; // Problem: https://github.com/animatedjs/animated/pull/102\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\n\nvar numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g; // Covers rgb, rgba, hsl, hsla\n// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e\n\nvar colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi; // Covers color names (transparent, blue, etc.)\n\nvar colorNamesRegex; // rgba requires that the r,g,b are integers.... so we want to round them,\n// but we *dont* want to round the opacity (4th column).\n\nvar rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi;\n\nvar rgbaRound = function (_, p1, p2, p3, p4) {\n  return \"rgba(\" + Math.round(p1) + \", \" + Math.round(p2) + \", \" + Math.round(p3) + \", \" + p4 + \")\";\n};\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *     \"rgba(123, 42, 99, 0.36)\"           // colors\n *     \"-45deg\"                            // values with units\n *     \"0 2px 2px 0px rgba(0, 0, 0, 0.12)\" // CSS box-shadows\n *     \"rotate(0deg) translate(2px, 3px)\"  // CSS transforms\n */\n\n\nexport var createStringInterpolator = function (config) {\n  if (!colorNamesRegex) colorNamesRegex = G.colorNames ? new RegExp(\"(\" + Object.keys(G.colorNames).join('|') + \")\", 'g') : /^\\b$/; // never match\n  // Convert colors to rgba(...)\n\n  var output = config.output.map(function (value) {\n    return getFluidValue(value).replace(colorRegex, colorToRgba).replace(colorNamesRegex, colorToRgba);\n  }); // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 2], [0, 0]]\n\n  var keyframes = output.map(function (value) {\n    return value.match(numberRegex).map(Number);\n  }); // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 0], [2, 0]]\n\n  var outputRanges = keyframes[0].map(function (_, i) {\n    return keyframes.map(function (values) {\n      if (!(i in values)) {\n        throw Error('The arity of each \"output\" value must be equal');\n      }\n\n      return values[i];\n    });\n  }); // Create an interpolator for each animated number\n\n  var interpolators = outputRanges.map(function (output) {\n    return createInterpolator(__assign(__assign({}, config), {\n      output: output\n    }));\n  }); // Use the first `output` as a template for each call\n\n  return function (input) {\n    var i = 0;\n    return output[0].replace(numberRegex, function () {\n      return String(interpolators[i++](input));\n    }).replace(rgbaRegex, rgbaRound);\n  };\n};","map":{"version":3,"sources":["../../src/stringInterpolation.ts"],"names":[],"mappings":";AAAA,SAAS,aAAT,QAA8B,QAA9B;AACA,SAAS,kBAAT,QAAmC,sBAAnC;AAEA,SAAS,WAAT,QAA4B,eAA5B;AACA,OAAO,KAAK,CAAZ,MAAmB,WAAnB,C,CAEA;AACA;;AACA,IAAM,WAAW,GAAG,mDAApB,C,CAEA;AACA;;AACA,IAAM,UAAU,GAAG,0FAAnB,C,CAEA;;AACA,IAAI,eAAJ,C,CAEA;AACA;;AACA,IAAM,SAAS,GAAG,8DAAlB;;AACA,IAAM,SAAS,GAAG,UAAC,CAAD,EAAS,EAAT,EAAqB,EAArB,EAAiC,EAAjC,EAA6C,EAA7C,EAAuD;AACvE,SAAA,UAAQ,IAAI,CAAC,KAAL,CAAW,EAAX,CAAR,GAAsB,IAAtB,GAA2B,IAAI,CAAC,KAAL,CAAW,EAAX,CAA3B,GAAyC,IAAzC,GAA8C,IAAI,CAAC,KAAL,CAAW,EAAX,CAA9C,GAA4D,IAA5D,GAAiE,EAAjE,GAAmE,GAAnE;AAAsE,CADxE;AAGA;;;;;;;;;AASG;;;AACH,OAAO,IAAM,wBAAwB,GAAG,UACtC,MADsC,EACJ;AAElC,MAAI,CAAC,eAAL,EACE,eAAe,GAAG,CAAC,CAAC,UAAF,GACd,IAAI,MAAJ,CAAW,MAAI,MAAM,CAAC,IAAP,CAAY,CAAC,CAAC,UAAd,EAA0B,IAA1B,CAA+B,GAA/B,CAAJ,GAAuC,GAAlD,EAAuD,GAAvD,CADc,GAEd,MAFJ,CAHgC,CAKrB;AAEb;;AACA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,GAAd,CAAkB,UAAA,KAAA,EAAK;AACpC,WAAA,aAAa,CAAC,KAAD,CAAb,CACG,OADH,CACW,UADX,EACuB,WADvB,EAEG,OAFH,CAEW,eAFX,EAE4B,WAF5B,CAAA;AAEwC,GAH3B,CAAf,CARkC,CAclC;;AACA,MAAM,SAAS,GAAG,MAAM,CAAC,GAAP,CAAW,UAAA,KAAA,EAAK;AAAI,WAAA,KAAK,CAAC,KAAN,CAAY,WAAZ,EAA0B,GAA1B,CAAA,MAAA,CAAA;AAAqC,GAAzD,CAAlB,CAfkC,CAiBlC;;AACA,MAAM,YAAY,GAAG,SAAS,CAAC,CAAD,CAAT,CAAa,GAAb,CAAiB,UAAC,CAAD,EAAI,CAAJ,EAAK;AACzC,WAAA,SAAS,CAAC,GAAV,CAAc,UAAA,MAAA,EAAM;AAClB,UAAI,EAAE,CAAC,IAAI,MAAP,CAAJ,EAAoB;AAClB,cAAM,KAAK,CAAC,gDAAD,CAAX;AACD;;AACD,aAAO,MAAM,CAAC,CAAD,CAAb;AACD,KALD,CAAA;AAKE,GANiB,CAArB,CAlBkC,CA2BlC;;AACA,MAAM,aAAa,GAAG,YAAY,CAAC,GAAb,CAAiB,UAAA,MAAA,EAAM;AAC3C,WAAA,kBAAkB,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAM,MAAN,CAAA,EAAY;AAAE,MAAA,MAAM,EAAA;AAAR,KAAZ,CAAA,CAAlB;AAAyC,GADrB,CAAtB,CA5BkC,CAgClC;;AACA,SAAO,UAAC,KAAD,EAAc;AACnB,QAAI,CAAC,GAAG,CAAR;AACA,WAAO,MAAM,CAAC,CAAD,CAAN,CACJ,OADI,CACI,WADJ,EACiB,YAAA;AAAM,aAAA,MAAM,CAAC,aAAa,CAAC,CAAC,EAAF,CAAb,CAAP,KAAO,CAAD,CAAN;AAAiC,KADxD,EAEJ,OAFI,CAEI,SAFJ,EAEe,SAFf,CAAP;AAGD,GALD;AAMD,CAxCM","sourcesContent":["import { getFluidValue } from 'fluids'\nimport { createInterpolator } from './createInterpolator'\nimport { InterpolatorConfig } from './types'\nimport { colorToRgba } from './colorToRgba'\nimport * as G from './globals'\n\n// Problem: https://github.com/animatedjs/animated/pull/102\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\nconst numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g\n\n// Covers rgb, rgba, hsl, hsla\n// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e\nconst colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi\n\n// Covers color names (transparent, blue, etc.)\nlet colorNamesRegex: RegExp\n\n// rgba requires that the r,g,b are integers.... so we want to round them,\n// but we *dont* want to round the opacity (4th column).\nconst rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi\nconst rgbaRound = (_: any, p1: number, p2: number, p3: number, p4: number) =>\n  `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`\n\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *     \"rgba(123, 42, 99, 0.36)\"           // colors\n *     \"-45deg\"                            // values with units\n *     \"0 2px 2px 0px rgba(0, 0, 0, 0.12)\" // CSS box-shadows\n *     \"rotate(0deg) translate(2px, 3px)\"  // CSS transforms\n */\nexport const createStringInterpolator = (\n  config: InterpolatorConfig<string>\n) => {\n  if (!colorNamesRegex)\n    colorNamesRegex = G.colorNames\n      ? new RegExp(`(${Object.keys(G.colorNames).join('|')})`, 'g')\n      : /^\\b$/ // never match\n\n  // Convert colors to rgba(...)\n  const output = config.output.map(value =>\n    getFluidValue(value)\n      .replace(colorRegex, colorToRgba)\n      .replace(colorNamesRegex, colorToRgba)\n  )\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 2], [0, 0]]\n  const keyframes = output.map(value => value.match(numberRegex)!.map(Number))\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 0], [2, 0]]\n  const outputRanges = keyframes[0].map((_, i) =>\n    keyframes.map(values => {\n      if (!(i in values)) {\n        throw Error('The arity of each \"output\" value must be equal')\n      }\n      return values[i]\n    })\n  )\n\n  // Create an interpolator for each animated number\n  const interpolators = outputRanges.map(output =>\n    createInterpolator({ ...config, output })\n  )\n\n  // Use the first `output` as a template for each call\n  return (input: number) => {\n    let i = 0\n    return output[0]\n      .replace(numberRegex, () => String(interpolators[i++](input)))\n      .replace(rgbaRegex, rgbaRound)\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}