{"ast":null,"code":"import { useLayoutEffect } from 'react-layout-effect';\nimport { each, is, toArray, isAnimatedString, getFluidConfig, Globals, FluidValue, getFluidValue, flush, isEqual, noop, useForceUpdate, usePrev, useOnce, createInterpolator } from '@react-spring/shared';\nexport { FrameLoop, Globals, createInterpolator } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createContext, useContext, createElement, useRef, useState, useMemo as useMemo$1, useImperativeHandle, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, setAnimated, AnimatedArray, AnimatedString } from '@react-spring/animated';\nimport { createStringInterpolator, batchedUpdates, to as to$1, frameLoop, skipAnimation } from '@react-spring/shared/globals';\nimport { useMemoOne, useCallbackOne } from 'use-memo-one';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\nexport * from '@react-spring/shared/types';\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame = 1000) {\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const {\n          controllers\n        } = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const {\n          controllers,\n          start\n        } = ref.current || {};\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n} // The `mass` prop defaults to 1\n\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst linear = t => t;\n\nconst defaults = _extends(_extends({}, config.default), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\n\nclass AnimationConfig {\n  /**\n   * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n   *\n   * When tension is zero, no animation occurs.\n   */\n\n  /**\n   * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n   *\n   * When `speed` is defined, this value should be between 0 and 1.\n   *\n   * Higher friction means the spring will slow down faster.\n   */\n\n  /**\n   * The natural frequency (in seconds), which dictates the number of bounces\n   * per second when no damping exists.\n   *\n   * When defined, `tension` is derived from this, and `friction` is derived\n   * from `tension` and `damping`.\n   */\n\n  /**\n   * The damping ratio, which dictates how the spring slows down.\n   *\n   * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n   * Between `0` and `1` is for you to explore.\n   *\n   * Only works when `frequency` is defined.\n   *\n   * Defaults to 1\n   */\n\n  /**\n   * Higher mass means more friction is required to slow down.\n   *\n   * Defaults to 1, which works fine most of the time.\n   */\n\n  /**\n   * The initial velocity of one or more values.\n   */\n\n  /**\n   * The smallest velocity before the animation is considered \"not moving\".\n   *\n   * When undefined, `precision` is used instead.\n   */\n\n  /**\n   * The smallest distance from a value before that distance is essentially zero.\n   *\n   * This helps in deciding when a spring is \"at rest\". The spring must be within\n   * this distance from its final value, and its velocity must be lower than this\n   * value too (unless `restVelocity` is defined).\n   */\n\n  /**\n   * For `duration` animations only. Note: The `duration` is not affected\n   * by this property.\n   *\n   * Defaults to `0`, which means \"start from the beginning\".\n   *\n   * Setting to `1+` makes an immediate animation.\n   *\n   * Setting to `0.5` means \"start from the middle of the easing function\".\n   *\n   * Any number `>= 0` and `<= 1` makes sense here.\n   */\n\n  /**\n   * Animation length in number of milliseconds.\n   */\n\n  /**\n   * The animation curve. Only used when `duration` is defined.\n   *\n   * Defaults to quadratic ease-in-out.\n   */\n\n  /**\n   * Avoid overshooting by ending abruptly at the goal value.\n   */\n\n  /**\n   * When above zero, the spring will bounce instead of overshooting when\n   * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n   * whenever its current value equals or exceeds its goal. For example,\n   * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n   * in addition to any friction.\n   */\n\n  /**\n   * \"Decay animations\" decelerate without an explicit goal value.\n   * Useful for scrolling animations.\n   *\n   * Use `true` for the default exponential decay factor (`0.998`).\n   *\n   * When a `number` between `0` and `1` is given, a lower number makes the\n   * animation slow down faster. And setting to `1` would make an unending\n   * animation.\n   */\n\n  /**\n   * While animating, round to the nearest multiple of this number.\n   * The `from` and `to` values are never rounded, as well as any value\n   * passed to the `set` method of an animated value.\n   */\n  constructor() {\n    this.tension = void 0;\n    this.friction = void 0;\n    this.frequency = void 0;\n    this.damping = void 0;\n    this.mass = void 0;\n    this.velocity = 0;\n    this.restVelocity = void 0;\n    this.precision = void 0;\n    this.progress = void 0;\n    this.duration = void 0;\n    this.easing = void 0;\n    this.clamp = void 0;\n    this.bounce = void 0;\n    this.decay = void 0;\n    this.round = void 0;\n    Object.assign(this, defaults);\n  }\n\n}\n\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends(_extends({}, defaultConfig), newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n} // Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\n\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nconst emptyArray = [];\n/** @internal */\n\n/** An animation being executed by the frameloop */\n\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.to = void 0;\n    this.from = void 0;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n    this.onStart = void 0;\n    this.onChange = void 0;\n    this.onRest = [];\n  }\n\n} // @see https://github.com/alexreardon/use-memo-one/pull/10\n\n\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\n\nfunction callProp(value, ...args) {\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\n\nconst getProps = (props, i, arg) => props && (is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props));\n/** Returns `true` if the given prop is having its default value set. */\n\n\nconst hasDefaultProp = (props, key) => !is.und(getDefaultProp(props, key));\n/** Get the default value being set for the given `key` */\n\n\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : undefined;\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\n\n\nconst getDefaultProps = (props, omitKeys = [], defaults = {}) => {\n  let keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  for (const key of keys) {\n    const value = props[key];\n\n    if (!is.und(value) && !omitKeys.includes(key)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\n/** Merge the default props of an update into a props cache. */\n\n\nconst mergeDefaultProps = (defaults, props, omitKeys) => getDefaultProps(props, omitKeys, defaults);\n/** These props can have default values */\n\n\nconst DEFAULT_PROPS = ['pause', 'cancel', 'config', 'immediate', 'onDelayEnd', 'onProps', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\n\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n\n  if (to) {\n    const out = {\n      to\n    };\n    each(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n\n  return _extends({}, props);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\n\nfunction computeGoal(value) {\n  const config = getFluidConfig(value);\n  return config ? computeGoal(config.get()) : is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\n\n\nfunction scheduleProps(callId, {\n  key,\n  props,\n  state,\n  actions\n}) {\n  return new Promise((resolve, reject) => {\n    let delay;\n    let timeout;\n    let pause = false;\n    let cancel = matchProp(props.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      delay = callProp(props.delay || 0, key);\n      pause = matchProp(props.pause, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      timeout.cancel(); // Cache the remaining delay.\n\n      delay = timeout.time - Globals.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause);\n        timeout = Globals.frameLoop.setTimeout(onStart, delay);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause); // Maybe cancelled during its delay.\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends(_extends({}, props), {}, {\n          callId,\n          delay,\n          cancel,\n          pause\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n/** @internal */\n\n/** The object given to the `onRest` prop and `start` promise. */\n\n/** The promised result of an animation. */\n\n/** @internal */\n\n\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target) : results.every(result => result.noop) ? getNoopResult(target) : getFinishedResult(target, results.every(result => result.finished));\n/** No-op results are for updates that never start an animation. */\n\n\nconst getNoopResult = (target, value = target.get()) => ({\n  value,\n  noop: true,\n  finished: true,\n  target\n});\n\nconst getFinishedResult = (target, finished, value = target.get()) => ({\n  value,\n  finished,\n  target\n});\n\nconst getCancelledResult = (target, value = target.get()) => ({\n  value,\n  cancelled: true,\n  target\n});\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\n\n\nasync function runAsync(to, props, state, target) {\n  if (props.pause) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to; // The default props of any `animate` calls.\n\n    const defaultProps = getDefaultProps(props, [// The `onRest` prop is only called when the `runAsync` promise is resolved.\n    'onRest']);\n    let preventBail;\n    let bail; // This promise is rejected when the animation is interrupted.\n\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject)); // Stop animating when an error is caught.\n\n    const withBailHandler = fn => (...args) => {\n      const onError = err => {\n        if (err instanceof BailSignal) {\n          bail(err); // Stop animating.\n        }\n\n        throw err;\n      };\n\n      try {\n        return fn(...args).catch(onError);\n      } catch (err) {\n        onError(err);\n      }\n    };\n\n    const bailIfEnded = bailSignal => {\n      const bailResult = // The `cancel` prop or `stop` method was used.\n      callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.\n      callId !== state.asyncId && getFinishedResult(target, false);\n\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        throw bailSignal;\n      }\n    }; // Note: This function cannot use the `async` keyword, because we want the\n    // `throw` statements to interrupt the caller.\n\n\n    const animate = withBailHandler((arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      bailIfEnded(bailSignal);\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        to: arg1\n      });\n      props.parentId = callId;\n      each(defaultProps, (value, key) => {\n        if (is.und(props[key])) {\n          props[key] = value;\n        }\n      });\n      return target.start(props).then(async result => {\n        bailIfEnded(bailSignal);\n\n        if (target.is('PAUSED')) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n\n        return result;\n      });\n    });\n    let result;\n\n    try {\n      let animating; // Async sequence\n\n      if (is.arr(to)) {\n        animating = (async queue => {\n          for (const props of queue) {\n            await animate(props);\n          }\n        })(to);\n      } // Async script\n      else if (is.fun(to)) {\n          animating = Promise.resolve(to(animate, target.stop.bind(target)));\n        }\n\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target, true); // Bail handling\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      } // Reset the async state.\n\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : undefined;\n        state.promise = parentId ? prevPromise : undefined;\n      }\n    }\n\n    if (is.fun(onRest)) {\n      batchedUpdates(() => {\n        onRest(result);\n      });\n    }\n\n    return result;\n  })();\n}\n\nfunction cancelAsync(state, callId) {\n  state.cancelId = callId;\n  state.asyncId = state.asyncTo = state.promise = undefined;\n}\n/** This error is thrown to signal an interrupted async animation. */\n\n\nclass BailSignal extends Error {\n  constructor() {\n    super('An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.');\n    this.result = void 0;\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\n\nlet nextId = 1;\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\n\nclass FrameValue extends FluidValue {\n  constructor(...args) {\n    super(...args);\n    this.id = nextId++;\n    this.key = void 0;\n    this._priority = 0;\n    this._children = new Set();\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n  /** Get the current value */\n\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n\n  to(...args) {\n    return to$1(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n\n  interpolate(...args) {\n    deprecateInterpolate();\n    return to$1(this, args);\n  }\n  /** @internal */\n\n  /** @internal */\n\n\n  addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n\n\n  removeChild(child) {\n    this._children.delete(child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (this.idle) {\n      // Start animating when a parent does.\n      if (type == 'start') {\n        this._reset();\n\n        this._start();\n      }\n    } // Reset our animation state when a parent does, but only when\n    // our animation is active.\n    else if (type == 'reset') {\n        this._reset();\n      }\n  }\n  /** Called when the first child is added. */\n\n\n  _attach() {}\n  /** Called when the last child is removed. */\n\n\n  _detach() {}\n  /**\n   * Reset our animation state (eg: start values, velocity, etc)\n   * and tell our children to do the same.\n   *\n   * This is called when our goal value is changed during (or before)\n   * an animation.\n   */\n\n\n  _reset() {\n    this._emit({\n      type: 'reset',\n      parent: this\n    });\n  }\n  /**\n   * Start animating if possible.\n   *\n   * Note: Be sure to call `_reset` first, or the animation will break.\n   * This method would like to call `_reset` for you, but that would\n   * interfere with paused animations.\n   */\n\n\n  _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Tell our children about our new value */\n\n\n  _onChange(value, idle = false) {\n    this._emit({\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n  /** Tell our children about our new priority */\n\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Make the frameloop aware of our new priority.\n      frameLoop.start(this);\n    }\n\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n\n  _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    each(Array.from(this._children), child => {\n      child.onParentChange(event);\n    });\n  }\n\n} // TODO: use \"const enum\" when Babel supports it\n\n/** The spring has not animated yet */\n\n\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\n\nclass SpringValue extends FrameValue {\n  /** The property name used when `to` or `from` is an object. Useful when debugging too. */\n\n  /** The animation state */\n\n  /** The queue of pending props */\n\n  /** The lifecycle phase of this spring */\n\n  /** The state for `runAsync` calls */\n\n  /** Some props have customizable default values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The last `scheduleProps` call that changed the `to` prop */\n  constructor(arg1, arg2) {\n    super();\n    this.key = void 0;\n    this.animation = new Animation();\n    this.queue = void 0;\n    this._phase = CREATED;\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._defaultProps = {};\n    this._lastCallId = 0;\n    this._lastToId = 0;\n\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        from: arg1\n      });\n      props.default = true;\n      this.start(props);\n    }\n  }\n\n  get idle() {\n    return !this.is(ACTIVE) && !this._state.asyncTo;\n  }\n\n  get goal() {\n    return getFluidValue(this.animation.to);\n  }\n\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n  /** Advance the current animation by a number of milliseconds */\n\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = getPayload(anim.to);\n\n    if (!payload) {\n      const toConfig = getFluidConfig(anim.to);\n\n      if (toConfig) {\n        toValues = toArray(toConfig.get());\n      }\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      let to = payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n\n      if (!finished) {\n        position = node.lastPosition; // Loose springs never move.\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n\n        const elapsed = node.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity; // Duration easing\n\n        if (!is.und(config.duration)) {\n          let p = config.progress || 0;\n          if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } // Decay easing\n        else if (config.decay) {\n            const decay = config.decay === true ? 0.998 : config.decay;\n            const e = Math.exp(-(1 - decay) * elapsed);\n            position = from + v0 / (1 - decay) * (1 - e);\n            finished = Math.abs(node.lastPosition - position) < 0.1; // derivative of position\n\n            velocity = v0 * e;\n          } // Spring easing\n          else {\n              velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n              /** The smallest distance from a value before being treated like said value. */\n\n              const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n              /** The velocity at which movement is essentially none */\n\n              const restVelocity = config.restVelocity || precision / 10; // Bouncing is opt-in (not to be confused with overshooting)\n\n              const bounceFactor = config.clamp ? 0 : config.bounce;\n              const canBounce = !is.und(bounceFactor);\n              /** When `true`, the value is increasing over time */\n\n              const isGrowing = from == to ? node.v0 > 0 : from < to;\n              /** When `true`, the velocity is considered moving */\n\n              let isMoving;\n              /** When `true`, the velocity is being deflected or clamped */\n\n              let isBouncing = false;\n              const step = 1; // 1ms\n\n              const numSteps = Math.ceil(dt / step);\n\n              for (let n = 0; n < numSteps; ++n) {\n                isMoving = Math.abs(velocity) > restVelocity;\n\n                if (!isMoving) {\n                  finished = Math.abs(to - position) <= precision;\n\n                  if (finished) {\n                    break;\n                  }\n                }\n\n                if (canBounce) {\n                  isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                  if (isBouncing) {\n                    velocity = -velocity * bounceFactor;\n                    position = to;\n                  }\n                }\n\n                const springForce = -config.tension * 0.000001 * (position - to);\n                const dampingForce = -config.friction * 0.001 * velocity;\n                const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n                velocity = velocity + acceleration * step; // pt/ms\n\n                position = position + velocity * step;\n              }\n            }\n\n        node.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(\"Got NaN while animating:\", this);\n          finished = true;\n        }\n      } // Parent springs must finish before their children can.\n\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n\n    return idle;\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    batchedUpdates(() => {\n      this._focus(value);\n\n      if (this._set(value)) {\n        // Ensure change observers are notified. When active,\n        // the \"_stop\" method handles this.\n        if (!this.is(ACTIVE)) {\n          return this._onChange(this.get(), true);\n        }\n      }\n\n      this._stop();\n    });\n    return this;\n  }\n  /**\n   * Freeze the active animation in time.\n   * This does nothing when not animating.\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.is(PAUSED)) {\n      this._phase = PAUSED;\n      flush(this._state.pauseQueue, onPause => onPause());\n    }\n  }\n  /** Resume the animation if paused. */\n\n\n  resume() {\n    checkDisposed(this, 'resume');\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      flush(this._state.resumeQueue, onResume => onResume());\n    }\n  }\n  /**\n   * Skip to the end of the current animation.\n   *\n   * All `onRest` callbacks are passed `{finished: true}`\n   */\n\n\n  finish(to) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      }\n\n      batchedUpdates(() => {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        if (!anim.changed) {\n          anim.changed = true;\n\n          if (anim.onStart) {\n            anim.onStart(this);\n          }\n        } // Exit the frameloop.\n\n\n        this._stop();\n      });\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update');\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start');\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends(_extends({}, arg2), {}, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    const results = await Promise.all(queue.map(props => this._update(props)));\n    return getCombinedResult(this, results);\n  }\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n\n\n  stop(cancel) {\n    if (!this.is(DISPOSED)) {\n      cancelAsync(this._state, this._lastCallId); // Ensure the `to` value equals the current value.\n\n      this._focus(this.get()); // Exit the frameloop and notify `onRest` listeners.\n\n\n      batchedUpdates(() => this._stop(cancel));\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = [];\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    super.onParentChange(event);\n\n    if (event.type == 'change') {\n      if (!this.is(ACTIVE)) {\n        this._reset();\n\n        if (!this.is(PAUSED)) {\n          this._start();\n        }\n      }\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n\n\n  _prepareNode({\n    to,\n    from,\n    reverse\n  }) {\n    const key = this.key || '';\n    to = !is.obj(to) || getFluidConfig(to) ? to : to[key];\n    from = !is.obj(from) || getFluidConfig(from) ? from : from[key]; // Create the range now to avoid \"reverse\" logic.\n\n    const range = {\n      to,\n      from\n    }; // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n\n    if (this.is(CREATED)) {\n      if (reverse) [to, from] = [from, to];\n      from = getFluidValue(from);\n\n      const node = this._updateNode(is.und(from) ? getFluidValue(to) : from);\n\n      if (node && !is.und(from)) {\n        node.setValue(from);\n      }\n    }\n\n    return range;\n  }\n  /**\n   * Create an `Animated` node if none exists or the given value has an\n   * incompatible type. Do nothing if `value` is undefined.\n   *\n   * The newest `Animated` node is returned.\n   */\n\n\n  _updateNode(value) {\n    let node = getAnimated(this);\n\n    if (!is.und(value)) {\n      const nodeType = this._getNodeType(value);\n\n      if (!node || node.constructor !== nodeType) {\n        setAnimated(this, node = nodeType.create(value));\n      }\n    }\n\n    return node;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parentNode = getAnimated(value);\n    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  }\n  /** Schedule an animation to run after an optional delay */\n\n\n  _update(props, isLoop) {\n    const defaultProps = this._defaultProps;\n\n    const mergeDefaultProp = key => {\n      const value = getDefaultProp(props, key);\n\n      if (!is.und(value)) {\n        defaultProps[key] = value;\n      } // For `cancel` and `pause`, a truthy default always wins.\n\n\n      if (defaultProps[key]) {\n        props[key] = defaultProps[key];\n      }\n    }; // These props are coerced into booleans by the `scheduleProps` function,\n    // so they need their default values processed before then.\n\n\n    mergeDefaultProp('cancel');\n    mergeDefaultProp('pause'); // Ensure the initial value can be accessed by animated components.\n\n    const range = this._prepareNode(props);\n\n    return scheduleProps(++this._lastCallId, {\n      key: this.key,\n      props,\n      state: this._state,\n      actions: {\n        pause: this.pause.bind(this),\n        resume: this.resume.bind(this),\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n  /** Merge props into the current animation */\n\n\n  _merge(range, props, resolve) {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    const {\n      key,\n      animation: anim\n    } = this;\n    const defaultProps = this._defaultProps;\n    /** The \"to\" prop is defined. */\n\n    const hasToProp = !is.und(range.to);\n    /** The \"from\" prop is defined. */\n\n    const hasFromProp = !is.und(range.from); // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    /** Get the value of a prop, or its default value */\n\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop]; // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n\n\n    const onDelayEnd = coerceEventProp(get('onDelayEnd'), key);\n\n    if (onDelayEnd) {\n      onDelayEnd(props, this);\n    }\n\n    if (props.default) {\n      mergeDefaultProps(defaultProps, props, ['pause', 'cancel']);\n    }\n\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range; // Focus the \"from\" value if changing without a \"to\" value.\n\n    if (hasFromProp && !hasToProp) {\n      to = from;\n    } // Flip the current range if \"reverse\" is true.\n\n\n    if (props.reverse) [to, from] = [from, to];\n    /** The \"from\" value is changing. */\n\n    const hasFromChanged = !isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    /** The \"to\" value is changing. */\n\n\n    const hasToChanged = !isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    } // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n\n\n    const toConfig = getFluidConfig(to);\n    const fromConfig = getFluidConfig(from);\n\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n    /** The \"to\" prop is async. */\n\n\n    const hasAsyncTo = is.arr(props.to) || is.fun(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config; // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), // Avoid calling the same \"config\" prop twice.\n      props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    } // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n\n\n    let node = getAnimated(this);\n\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    /** When true, start at the \"from\" value. */\n\n\n    const reset = // When `reset` is undefined, the `from` prop implies `reset: true`,\n    // except for declarative updates. When `reset` is defined, there\n    // must exist a value to animate from.\n    is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key); // The current value, where the animation starts from.\n\n    const value = reset ? from : this.get(); // The animation ends at this value, unless \"to\" is fluid.\n\n    const goal = computeGoal(to); // Only specific types can be animated to/from.\n\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal); // When true, the value changes instantly on the next frame.\n\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      if (immediate) {\n        node = this._updateNode(goal);\n      } else {\n        const nodeType = this._getNodeType(to);\n\n        if (nodeType !== node.constructor) {\n          throw Error(\"Cannot animate between \" + node.constructor.name + \" and \" + nodeType.name + \", as the \\\"to\\\" prop suggests\");\n        }\n      }\n    } // The type of Animated node for the goal value.\n\n\n    const goalType = node.constructor; // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n\n    let started = !!toConfig;\n    let finished = false;\n\n    if (!started) {\n      // When true, the current value has probably changed.\n      const hasValueChanged = reset || this.is(CREATED) && hasFromChanged; // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal);\n        started = !finished;\n      } // Changing \"decay\" or \"velocity\" starts the animation.\n\n\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    } // When an active animation changes its goal to its current value:\n\n\n    if (finished && this.is(ACTIVE)) {\n      // Avoid an abrupt stop unless the animation is being reset.\n      if (anim.changed && !reset) {\n        started = true;\n      } // Stop the animation before its first frame.\n      else if (!started) {\n          this._stop();\n        }\n    }\n\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || getFluidConfig(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = toConfig ? null : goalType == AnimatedString ? [1] : toArray(goal);\n      }\n\n      anim.immediate = immediate;\n      anim.onStart = coerceEventProp(get('onStart'), key);\n      anim.onChange = coerceEventProp(get('onChange'), key); // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n      // unless you defined a new \"onRest\" prop.\n\n      const onRestQueue = anim.onRest;\n      const onRest = reset && !props.onRest ? onRestQueue[0] || noop : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this); // In most cases, the animation after this one won't reuse our\n      // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n      // when the next animation has an undefined \"onRest\" prop.\n\n      if (started) {\n        anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]; // Flush the \"onRest\" queue for the previous animation.\n\n        let onRestIndex = reset ? 0 : 1;\n\n        if (onRestIndex < onRestQueue.length) {\n          batchedUpdates(() => {\n            for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n              onRestQueue[onRestIndex]();\n            }\n          });\n        }\n      } // The \"onRest\" prop is always first, and it can be updated even\n      // if a new animation is not started by this update.\n      else if (reset || props.onRest) {\n          anim.onRest[0] = onRest;\n        }\n    } // By this point, every prop has been merged.\n\n\n    const onProps = coerceEventProp(get('onProps'), key);\n\n    if (onProps) {\n      onProps(props, this);\n    } // Update our node even if the animation is idle.\n\n\n    if (reset) {\n      node.setValue(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } // Start an animation\n    else if (started) {\n        // Must be idle for \"onStart\" to be called again.\n        if (reset) this._phase = IDLE;\n\n        this._reset();\n\n        this._start();\n      } // Postpone promise resolution until the animation is finished,\n      // so that no-op updates still resolve at the expected time.\n      else if (this.is(ACTIVE) && !hasToChanged) {\n          anim.onRest.push(checkFinishedOnRest(resolve, this));\n        } // Resolve our promise immediately.\n        else {\n            resolve(getNoopResult(this, value));\n          }\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _focus(value) {\n    const anim = this.animation;\n\n    if (value !== anim.to) {\n      let config = getFluidConfig(anim.to);\n\n      if (config) {\n        config.removeChild(this);\n      }\n\n      anim.to = value;\n      let priority = 0;\n\n      if (config = getFluidConfig(value)) {\n        config.addChild(this);\n\n        if (isFrameValue(value)) {\n          priority = (value.priority || 0) + 1;\n        }\n      }\n\n      this.priority = priority;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    const config = getFluidConfig(value);\n\n    if (config) {\n      value = config.get();\n    }\n\n    const node = getAnimated(this);\n    const oldValue = node && node.getValue();\n\n    if (node) {\n      node.setValue(value);\n    } else {\n      this._updateNode(value);\n    }\n\n    return !isEqual(value, oldValue);\n  }\n\n  _onChange(value, idle = false) {\n    const anim = this.animation; // The \"onStart\" prop is called on the first change after entering the\n    // frameloop, but never for immediate animations.\n\n    if (!anim.changed && !idle) {\n      anim.changed = true;\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n\n  _reset() {\n    const anim = this.animation; // Reset the state of each Animated node.\n\n    getAnimated(this).reset(anim.to); // Ensure the `onStart` prop will be called.\n\n    if (!this.is(ACTIVE)) {\n      anim.changed = false;\n    } // Use the current values as the from values.\n\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n\n    super._reset();\n  }\n\n  _start() {\n    if (!this.is(ACTIVE)) {\n      this._phase = ACTIVE;\n\n      super._start(); // The \"skipAnimation\" global avoids the frameloop.\n\n\n      if (skipAnimation) {\n        this.finish();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n\n\n  _stop(cancel) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      each(anim.values, node => {\n        node.done = true;\n      });\n      const onRestQueue = anim.onRest;\n\n      if (onRestQueue.length) {\n        // Preserve the \"onRest\" prop when the goal is dynamic.\n        anim.onRest = [anim.toValues ? noop : onRestQueue[0]]; // Never call the \"onRest\" prop for no-op animations.\n\n        if (!anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        each(onRestQueue, onRest => onRest(cancel));\n      }\n    }\n  }\n\n}\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\"Cannot call \\\"\" + name + \"\\\" of disposed \\\"\" + spring.constructor.name + \"\\\" object\");\n  }\n}\n/** Coerce an event prop to an event handler */\n\n\nfunction coerceEventProp(prop, key) {\n  return is.fun(prop) ? prop : key && prop ? prop[key] : undefined;\n}\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\n\n\nconst checkFinishedOnRest = (onRest, spring) => {\n  const {\n    to\n  } = spring.animation;\n  return onRest ? cancel => {\n    if (cancel) {\n      onRest(getCancelledResult(spring));\n    } else {\n      const goal = computeGoal(to);\n      const value = computeGoal(spring.get());\n      const finished = isEqual(value, goal);\n      onRest(getFinishedResult(spring, finished));\n    }\n  } : noop;\n};\n\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\n  let loopRet = callProp(loop);\n\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate(_extends(_extends({}, props), {}, {\n      loop,\n      // Avoid updating default props when looping.\n      default: false,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || is.arr(to) || is.fun(to) ? to : undefined,\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset\n    }, overrides));\n  }\n}\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\n\n\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props); // Collect the keys affected by this update.\n\n  const keys = new Set();\n\n  if (from) {\n    findDefined(from, keys);\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from;\n  }\n\n  if (is.obj(to)) {\n    findDefined(to, keys);\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to;\n  } // The \"keys\" prop helps in applying updates to affected keys only.\n\n\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\n\n\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update, [// Avoid forcing `immediate: true` onto imperative updates.\n    update.immediate === true && 'immediate']);\n  }\n\n  return update;\n}\n/** Find keys with defined values */\n\n\nfunction findDefined(values, keys) {\n  each(values, (value, key) => value != null && keys.add(key));\n}\n/** Events batched by the `Controller` class */\n\n\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nlet nextId$1 = 1;\n/** Queue of pending updates for a `Controller` instance. */\n\nclass Controller {\n  /** The animated values */\n\n  /** The queue of props passed to the `update` method. */\n\n  /** Custom handler for flushing update queues */\n\n  /** These props are used by all future spring values */\n\n  /** The combined phase of our spring values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The values currently being animated */\n\n  /** State used by the `runAsync` function */\n\n  /** The event queues that are flushed once per frame maximum */\n  constructor(props, flush) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._phase = CREATED;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(props);\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => spring.idle);\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Get the current values of our springs */\n\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(createUpdate(props));\n    return this;\n  }\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n\n\n  start(props) {\n    const queue = props ? toArray(props).map(createUpdate) : this.queue;\n\n    if (!props) {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.stop());\n      cancelAsync(this._state, this._lastAsyncId);\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Freeze the active animation in time */\n\n\n  pause(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.pause());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].pause());\n    }\n\n    return this;\n  }\n  /** Resume the animation if paused. */\n\n\n  resume(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.resume());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].resume());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    this.each(spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Call a function once per spring value */\n\n\n  each(iterator) {\n    each(this.springs, iterator);\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._state.asyncTo = undefined;\n    this.each(spring => spring.dispose());\n    this.springs = {};\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const isActive = this._active.size > 0;\n\n    if (isActive && this._phase != ACTIVE) {\n      this._phase = ACTIVE;\n      flush(onStart, onStart => onStart(this));\n    }\n\n    const values = (onChange.size || !isActive && onRest.size) && this.get();\n    flush(onChange, onChange => onChange(values)); // The \"onRest\" queue is only flushed when all springs are idle.\n\n    if (!isActive) {\n      this._phase = IDLE;\n      flush(onRest, ([onRest, result]) => {\n        result.value = values;\n        onRest(result);\n      });\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (event.type == 'change') {\n      this._active[event.idle ? 'delete' : 'add'](event.parent);\n\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n\n}\n/**\n * Warning: Props might be mutated.\n */\n\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\n\n\nfunction flushUpdate(ctrl, props, isLoop) {\n  const {\n    to,\n    loop,\n    onRest\n  } = props; // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  const asyncTo = is.arr(to) || is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n\n      if (is.fun(handler)) {\n        const queue = ctrl['_events'][key];\n\n        if (queue instanceof Set) {\n          props[key] = () => queue.add(handler);\n        } else {\n          props[key] = ({\n            finished,\n            cancelled\n          }) => {\n            const result = queue.get(handler);\n\n            if (result) {\n              if (!finished) result.finished = false;\n              if (cancelled) result.cancelled = true;\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished,\n                cancelled\n              });\n            }\n          };\n        }\n      }\n    });\n  }\n\n  const keys = props.keys || Object.keys(ctrl.springs);\n  const promises = keys.map(key => ctrl.springs[key].start(props)); // Schedule the \"asyncTo\" if defined.\n\n  const state = ctrl['_state'];\n\n  if (asyncTo) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n\n        start(props, resolve) {\n          props.onRest = onRest;\n\n          if (!props.cancel) {\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          } // Prevent `cancel: true` from ending the current `runAsync` call,\n          // except when the default `cancel` prop is being set.\n          else if (hasDefaultProp(props, 'cancel')) {\n              cancelAsync(state, props.callId);\n            }\n        }\n\n      }\n    }));\n  } // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n      cancelAsync(state, ctrl['_lastAsyncId']);\n    }\n\n  return Promise.all(promises).then(results => {\n    const result = getCombinedResult(ctrl, results);\n\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      const nextProps = createLoopUpdate(props, loop, to);\n\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps]);\n        return flushUpdate(ctrl, nextProps, true);\n      }\n    }\n\n    return result;\n  });\n}\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\n\n\nfunction getSprings(ctrl, props) {\n  const springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    each(toArray(props), props => {\n      if (is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = _extends(_extends({}, props), {}, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, key => {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\n\n\nfunction setSprings(ctrl, springs) {\n  each(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      spring.addChild(ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    spring.addChild(observer);\n  }\n\n  return spring;\n}\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\n\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\n\n\nfunction prepareKeys(ctrl, queue) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\n\n\nconst ctx = createContext({});\n\nconst SpringContext = _ref => {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  const inherited = useContext(ctx); // Memoize the context to avoid unwanted renders.\n\n  props = useMemo(() => _extends(_extends({}, inherited), props), [inherited, props.pause, props.cancel, props.immediate, props.config]);\n  const {\n    Provider\n  } = ctx;\n  return /*#__PURE__*/createElement(Provider, {\n    value: props\n  }, children);\n};\n\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n/** Get the current values of nearest `SpringContext` component. */\n\nconst useSpringContext = () => useContext(ctx);\n/** Create an imperative API for manipulating an array of `Controller` objects. */\n\n\nconst SpringHandle = {\n  create: getControllers => ({\n    get controllers() {\n      return getControllers();\n    },\n\n    update(props) {\n      each(getControllers(), (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n      });\n      return this;\n    },\n\n    async start(props) {\n      const results = await Promise.all(getControllers().map((ctrl, i) => {\n        const update = getProps(props, i, ctrl);\n        return ctrl.start(update);\n      }));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(getControllers(), ctrl => ctrl.stop(keys)),\n    pause: keys => each(getControllers(), ctrl => ctrl.pause(keys)),\n    resume: keys => each(getControllers(), ctrl => ctrl.resume(keys))\n  })\n};\n/** @internal */\n\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = []; // Set to 0 to prevent sync flush.\n\n  const layoutId = useRef(0);\n  const forceUpdate = useForceUpdate(); // State is updated on commit.\n\n  const [state] = useState(() => ({\n    ctrls: [],\n    queue: [],\n\n    flush(ctrl, updates) {\n      const springs = getSprings(ctrl, updates); // Flushing is postponed until the component's commit phase\n      // if a spring was created since the last commit.\n\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(resolve => {\n        setSprings(ctrl, springs);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates));\n        });\n        forceUpdate();\n      });\n    }\n\n  })); // The imperative API ref from the props of the first controller.\n\n  const refProp = useRef();\n  const ctrls = [...state.ctrls];\n  const updates = []; // Cache old controllers to dispose in the commit phase.\n\n  const prevLength = usePrev(length) || 0;\n  const disposed = ctrls.slice(length, prevLength); // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n\n  useMemo(() => {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]); // Update existing controllers when \"deps\" are changed.\n\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  /** Fill the `updates` array with declarative updates for the given index range. */\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n      let update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update = updates[i] = declareUpdate(update);\n\n        if (i == 0) {\n          refProp.current = update.ref;\n          update.ref = undefined;\n        }\n      }\n    }\n  }\n\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => state.ctrls);\n  }, []); // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = useSpringContext();\n  useLayoutEffect(() => {\n    layoutId.current++; // Replace the cached controllers.\n\n    state.ctrls = ctrls; // Update the ref prop.\n\n    if (refProp.current) {\n      refProp.current.current = api;\n    } // Flush the commit queue.\n\n\n    const {\n      queue\n    } = state;\n\n    if (queue.length) {\n      state.queue = [];\n      each(queue, cb => cb());\n    } // Dispose unused controllers.\n\n\n    each(disposed, ctrl => ctrl.dispose()); // Update existing controllers.\n\n    each(ctrls, (ctrl, i) => {\n      const values = springs[i];\n      setSprings(ctrl, values); // Update the default props.\n\n      ctrl.start({\n        default: context\n      }); // Apply updates created during render.\n\n      const update = updates[i];\n\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  }); // Dispose all controllers on unmount.\n\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.dispose());\n  }); // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n\n  const values = springs.map(x => _extends({}, x));\n  return propsFn || arguments.length == 3 ? [values, api.start, api.stop] : values;\n}\n/**\n * The props that `useSpring` recognizes.\n */\n\n/** @internal */\n\n\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], update, stop] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, // Ensure the props function is called when no deps exist.\n  // This works around the 3 argument rule.\n  deps || [{}]);\n  useLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    const update = result[1];\n    result[1] = useCallbackOne(propsArg => {\n      const reverse = is.obj(propsArg) && propsArg.reverse;\n      return update((i, ctrl) => {\n        const props = getProps(propsArg, i, ctrl);\n        const parent = ctrls[i + (reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      });\n    }, deps);\n    return result;\n  }\n\n  return result[0];\n} // TODO: convert to \"const enum\" once Babel supports it\n\n/** This transition is being mounted */\n\n\nconst MOUNT = 'mount';\n/** This transition is entering or has entered */\n\nconst ENTER = 'enter';\n/** This transition had its animations updated */\n\nconst UPDATE = 'update';\n/** This transition will expire after animating */\n\nconst LEAVE = 'leave';\n\nfunction useTransition(data, props, deps) {\n  const {\n    ref,\n    reset,\n    sort,\n    trail = 0,\n    expires = true\n  } = props; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends(_extends({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate(); // These props are inherited by every phase change.\n\n  const defaultProps = getDefaultProps(props); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    let to;\n    let phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      const config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends(_extends({}, defaultProps), {}, {\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false\n    }, to);\n\n    if (phase == ENTER && is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    const {\n      onRest\n    } = payload;\n\n    payload.onRest = result => {\n      const transitions = usedTransitions.current;\n      const t = transitions.find(t => t.key === key);\n      if (!t) return;\n\n      if (is.fun(onRest)) {\n        onRest(result, t);\n      } // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n\n\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase;\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle);\n\n        if (t.phase == LEAVE) {\n          const expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true; // Force update once the expiration delay ends.\n\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        } // Force update once idle and expired items exist.\n\n\n        if (idle && transitions.some(t => t.expired)) {\n          forceUpdate();\n        }\n      }\n    };\n\n    const springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase,\n      springs,\n      payload\n    });\n  }); // The prop overrides from an ancestor.\n\n  const context = useSpringContext(); // Merge the context into each transition.\n\n  useLayoutEffect(() => {\n    each(transitions, t => {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => {\n      return usedTransitions.current.map(t => t.ctrl);\n    });\n  }, []);\n  useImperativeHandle(ref, () => api);\n  useLayoutEffect(() => {\n    each(changes, ({\n      phase,\n      springs,\n      payload\n    }, t) => {\n      setSprings(t.ctrl, springs);\n\n      if (!context.cancel) {\n        t.phase = phase;\n\n        if (phase == ENTER) {\n          t.ctrl.start({\n            default: context\n          });\n        }\n\n        t.ctrl[ref ? 'update' : 'start'](payload);\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  const renderTransitions = render => /*#__PURE__*/createElement(Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render(_extends({}, springs), t.item, t, i);\n    return elem && elem.type ? /*#__PURE__*/createElement(elem.type, _extends({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  }));\n\n  return arguments.length == 3 ? [renderTransitions, api.start, api.stop] : renderTransitions;\n}\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}) {\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\n\n\nfunction Spring(_ref) {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  return /*#__PURE__*/createElement(Fragment, null, useTransition(items, props)(children));\n}\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\n\n\nclass Interpolation extends FrameValue {\n  /** Useful for debugging. */\n\n  /** Equals false when in the frameloop */\n\n  /** The function that maps inputs values to output */\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.key = void 0;\n    this.idle = true;\n    this.calc = void 0;\n    this.calc = createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = is.arr(value) ? AnimatedArray : AnimatedValue; // Assume the computed value never changes type.\n\n    setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n  }\n\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n\n  _reset() {\n    each(getPayload(this), node => node.reset());\n\n    super._reset();\n  }\n\n  _start() {\n    this.idle = false;\n\n    super._start();\n\n    if (skipAnimation) {\n      this.idle = true;\n      this.advance();\n    } else {\n      frameLoop.start(this);\n    }\n  }\n\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let idle = true;\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n\n      source.addChild(this);\n    });\n    this.priority = priority;\n\n    if (!idle) {\n      this._reset();\n\n      this._start();\n    }\n  }\n\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    }); // This removes us from the frameloop.\n\n    this.idle = true;\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    // Ensure our start value respects our parent values, in case\n    // any of their animations were restarted with the \"reset\" prop.\n    if (event.type == 'start') {\n      this.advance();\n    } // Change events are useful for (1) reacting to non-animated parents\n    // and (2) reacting to the last change in a parent animation.\n    else if (event.type == 'change') {\n        // If we're idle, we know for sure that this change is *not*\n        // caused by an animation.\n        if (this.idle) {\n          this.advance();\n        } // Leave the frameloop when all parents are done animating.\n        else if (event.idle) {\n            this.idle = toArray(this.source).every(source => source.idle !== false);\n\n            if (this.idle) {\n              this.advance();\n              each(getPayload(this), node => {\n                node.done = true;\n              });\n            }\n          }\n      } // Ensure our priority is greater than all parents, which means\n      // our value won't be updated until our parents have updated.\n      else if (event.type == 'priority') {\n          this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n        }\n\n    super.onParentChange(event);\n  }\n\n}\n/** Map the value of one or more dependencies */\n\n\nconst to = (source, ...args) => new Interpolation(source, args);\n/** @deprecated Use the `to` export instead */\n\n\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\n/** Extract the raw value types that are being interpolated */\n\n\nGlobals.assign({\n  createStringInterpolator: createStringInterpolator$1,\n  to: (source, args) => new Interpolation(source, args)\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.advance();\n\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringHandle, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };","map":{"version":3,"sources":["src/hooks/useChain.js","src/constants.ts","src/AnimationConfig.ts","src/Animation.ts","src/helpers.ts","src/scheduleProps.ts","src/AnimationResult.ts","src/runAsync.ts","src/FrameValue.ts","src/SpringPhase.ts","src/SpringValue.ts","src/Controller.ts","src/SpringContext.tsx","src/SpringHandle.ts","src/hooks/useSprings.ts","src/hooks/useSpring.ts","src/hooks/useTrail.ts","src/TransitionPhase.ts","src/hooks/useTransition.tsx","src/components/Spring.tsx","src/components/Trail.tsx","src/components/Transition.tsx","src/Interpolation.ts","src/interpolate.ts","src/globals.ts"],"names":["timeFrame","useLayoutEffect","prevDelay","each","ref","controllers","delay","timeSteps","isNaN","ctrl","props","p","Promise","start","updates","q","config","default","tension","friction","gentle","wobbly","stiff","slow","molasses","linear","t","defaults","configs","mass","damping","easing","clamp","frequency","velocity","restVelocity","precision","progress","duration","bounce","decay","round","constructor","Object","defaultConfig","sanitizeConfig","newConfig","is","Math","isTensionConfig","emptyArray","useMemo","useMemoOne","deps","value","matchProp","key","toArray","getProps","hasDefaultProp","getDefaultProp","getDefaultProps","omitKeys","keys","mergeDefaultProps","DEFAULT_PROPS","RESERVED_PROPS","from","to","loop","reset","pause","cancel","reverse","immediate","onDelayEnd","onProps","onStart","onChange","onRest","items","trail","sort","expires","initial","enter","update","leave","children","callId","parentId","forward","count","getForwardProps","out","getFluidConfig","computeGoal","range","output","actions","callProp","state","onResume","timeout","G","reject","getCombinedResult","results","result","getCancelledResult","getNoopResult","getFinishedResult","target","noop","finished","cancelled","resume","asyncTo","promise","prevPromise","defaultProps","bailPromise","preventBail","bail","withBailHandler","fn","onError","err","bailIfEnded","bailSignal","bailResult","animate","arg1","animating","isFrameValue","nextId","get","node","getAnimated","interpolate","deprecateInterpolate","addChild","removeChild","onParentChange","type","_attach","_detach","_reset","parent","_start","_onChange","idle","_onPriorityChange","priority","_emit","Array","child","CREATED","IDLE","ACTIVE","PAUSED","DISPOSED","animation","queue","_phase","_state","pauseQueue","resumeQueue","_defaultProps","_lastCallId","_lastToId","getFluidValue","advance","changed","anim","toValues","payload","getPayload","toConfig","position","elapsed","v0","e","bounceFactor","canBounce","isGrowing","isBouncing","step","numSteps","dt","n","isMoving","springForce","dampingForce","acceleration","Number","console","set","checkDisposed","flush","onPause","finish","stop","cancelAsync","dispose","event","_prepareNode","_updateNode","nodeType","setAnimated","_getNodeType","parentNode","isAnimatedString","_update","mergeDefaultProp","isLoop","nextProps","createLoopUpdate","_merge","resolve","hasToProp","hasFromProp","prop","coerceEventProp","prevFrom","hasFromChanged","isEqual","hasToChanged","fromConfig","hasAsyncTo","mergeConfig","goal","isAnimatable","Error","goalType","started","hasValueChanged","onRestQueue","checkFinishedOnRest","onRestIndex","runAsync","_focus","_set","oldValue","_stop","spring","loopRet","overrides","inferTo","createUpdate","findDefined","BATCHED_EVENTS","id","springs","_flush","_initialProps","_lastAsyncId","_active","_events","values","prepareKeys","flushUpdateQueue","_onFrame","isActive","flushUpdate","handler","promises","scheduleProps","undefined","prepareSprings","createSpring","create","ctx","React","SpringContext","inherited","useContext","Provider","useSpringContext","SpringHandle","getControllers","propsFn","layoutId","useRef","forceUpdate","useForceUpdate","useState","ctrls","getSprings","canFlushSync","setSprings","refProp","prevLength","usePrev","disposed","declareUpdates","i","declareUpdate","api","context","cb","useOnce","x","arguments","isFn","useSprings","propsArg","useCallbackOne","MOUNT","ENTER","UPDATE","LEAVE","transitions","getKeys","usedTransitions","prevTransitions","clearTimeout","reused","phase","item","a","b","changes","prevPhase","isLeave","expiry","expiryMs","setTimeout","useImperativeHandle","renderTransitions","render","elem","useSpring","trails","useTrail","React.createElement","useTransition","calc","source","createInterpolator","_get","inputs","Globals","createStringInterpolator"],"mappings":"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","sourcesContent":["import { useLayoutEffect } from 'react-layout-effect';\nimport { each, is, toArray, isAnimatedString, getFluidConfig, Globals, FluidValue, getFluidValue, flush, isEqual, noop, useForceUpdate, usePrev, useOnce, createInterpolator } from '@react-spring/shared';\nexport { FrameLoop, Globals, createInterpolator } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { createContext, useContext, createElement, useRef, useState, useMemo as useMemo$1, useImperativeHandle, Fragment } from 'react';\nimport { getAnimated, AnimatedValue, getPayload, setAnimated, AnimatedArray, AnimatedString } from '@react-spring/animated';\nimport { createStringInterpolator, batchedUpdates, to as to$1, frameLoop, skipAnimation } from '@react-spring/shared/globals';\nimport { useMemoOne, useCallbackOne } from 'use-memo-one';\nimport { deprecateInterpolate } from '@react-spring/shared/deprecations';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { createStringInterpolator as createStringInterpolator$1 } from '@react-spring/shared/stringInterpolation';\nexport * from '@react-spring/shared/types';\n\n/** API\n *  useChain(references, timeSteps, timeFrame)\n */\n\nfunction useChain(refs, timeSteps, timeFrame = 1000) {\n  useLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      each(refs, (ref, i) => {\n        if (!ref.current) return;\n        const {\n          controllers\n        } = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i]; // Use the previous delay if none exists.\n\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          each(controllers, ctrl => {\n            each(ctrl.queue, props => {\n              props.delay = delay + (props.delay || 0);\n            });\n            ctrl.start();\n          });\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      each(refs, ref => {\n        const {\n          controllers,\n          start\n        } = ref.current || {};\n\n        if (controllers && controllers.length) {\n          // Take the queue of each controller\n          const updates = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          }); // Apply the queue when the previous ref stops animating\n\n          p = p.then(() => {\n            each(controllers, (ctrl, i) => ctrl.queue.push(...updates[i]));\n            return start();\n          });\n        }\n      });\n    }\n  });\n}\n\n// The `mass` prop defaults to 1\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst linear = t => t;\n\nconst defaults = _extends(_extends({}, config.default), {}, {\n  mass: 1,\n  damping: 1,\n  easing: linear,\n  clamp: false\n});\n\nclass AnimationConfig {\n  /**\n   * With higher tension, the spring will resist bouncing and try harder to stop at its end value.\n   *\n   * When tension is zero, no animation occurs.\n   */\n\n  /**\n   * The damping ratio coefficient, or just the damping ratio when `speed` is defined.\n   *\n   * When `speed` is defined, this value should be between 0 and 1.\n   *\n   * Higher friction means the spring will slow down faster.\n   */\n\n  /**\n   * The natural frequency (in seconds), which dictates the number of bounces\n   * per second when no damping exists.\n   *\n   * When defined, `tension` is derived from this, and `friction` is derived\n   * from `tension` and `damping`.\n   */\n\n  /**\n   * The damping ratio, which dictates how the spring slows down.\n   *\n   * Set to `0` to never slow down. Set to `1` to slow down without bouncing.\n   * Between `0` and `1` is for you to explore.\n   *\n   * Only works when `frequency` is defined.\n   *\n   * Defaults to 1\n   */\n\n  /**\n   * Higher mass means more friction is required to slow down.\n   *\n   * Defaults to 1, which works fine most of the time.\n   */\n\n  /**\n   * The initial velocity of one or more values.\n   */\n\n  /**\n   * The smallest velocity before the animation is considered \"not moving\".\n   *\n   * When undefined, `precision` is used instead.\n   */\n\n  /**\n   * The smallest distance from a value before that distance is essentially zero.\n   *\n   * This helps in deciding when a spring is \"at rest\". The spring must be within\n   * this distance from its final value, and its velocity must be lower than this\n   * value too (unless `restVelocity` is defined).\n   */\n\n  /**\n   * For `duration` animations only. Note: The `duration` is not affected\n   * by this property.\n   *\n   * Defaults to `0`, which means \"start from the beginning\".\n   *\n   * Setting to `1+` makes an immediate animation.\n   *\n   * Setting to `0.5` means \"start from the middle of the easing function\".\n   *\n   * Any number `>= 0` and `<= 1` makes sense here.\n   */\n\n  /**\n   * Animation length in number of milliseconds.\n   */\n\n  /**\n   * The animation curve. Only used when `duration` is defined.\n   *\n   * Defaults to quadratic ease-in-out.\n   */\n\n  /**\n   * Avoid overshooting by ending abruptly at the goal value.\n   */\n\n  /**\n   * When above zero, the spring will bounce instead of overshooting when\n   * exceeding its goal value. Its velocity is multiplied by `-1 + bounce`\n   * whenever its current value equals or exceeds its goal. For example,\n   * setting `bounce` to `0.5` chops the velocity in half on each bounce,\n   * in addition to any friction.\n   */\n\n  /**\n   * \"Decay animations\" decelerate without an explicit goal value.\n   * Useful for scrolling animations.\n   *\n   * Use `true` for the default exponential decay factor (`0.998`).\n   *\n   * When a `number` between `0` and `1` is given, a lower number makes the\n   * animation slow down faster. And setting to `1` would make an unending\n   * animation.\n   */\n\n  /**\n   * While animating, round to the nearest multiple of this number.\n   * The `from` and `to` values are never rounded, as well as any value\n   * passed to the `set` method of an animated value.\n   */\n  constructor() {\n    this.tension = void 0;\n    this.friction = void 0;\n    this.frequency = void 0;\n    this.damping = void 0;\n    this.mass = void 0;\n    this.velocity = 0;\n    this.restVelocity = void 0;\n    this.precision = void 0;\n    this.progress = void 0;\n    this.duration = void 0;\n    this.easing = void 0;\n    this.clamp = void 0;\n    this.bounce = void 0;\n    this.decay = void 0;\n    this.round = void 0;\n    Object.assign(this, defaults);\n  }\n\n}\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends(_extends({}, defaultConfig), newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n\n  if (!is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n} // Prevent a config from accidentally overriding new props.\n// This depends on which \"config\" props take precedence when defined.\n\nfunction sanitizeConfig(config, props) {\n  if (!is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);\n\n    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nconst emptyArray = [];\n/** @internal */\n\n/** An animation being executed by the frameloop */\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.to = void 0;\n    this.from = void 0;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n    this.onStart = void 0;\n    this.onChange = void 0;\n    this.onRest = [];\n  }\n\n}\n\n// @see https://github.com/alexreardon/use-memo-one/pull/10\nconst useMemo = (create, deps) => useMemoOne(create, deps || [{}]);\nfunction callProp(value, ...args) {\n  return is.fun(value) ? value(...args) : value;\n}\n/** Try to coerce the given value into a boolean using the given key */\n\nconst matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));\nconst getProps = (props, i, arg) => props && (is.fun(props) ? props(i, arg) : is.arr(props) ? props[i] : _extends({}, props));\n/** Returns `true` if the given prop is having its default value set. */\n\nconst hasDefaultProp = (props, key) => !is.und(getDefaultProp(props, key));\n/** Get the default value being set for the given `key` */\n\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : undefined;\n/**\n * Extract the default props from an update.\n *\n * When the `default` prop is falsy, this function still behaves as if\n * `default: true` was used. The `default` prop is always respected when\n * truthy.\n */\n\nconst getDefaultProps = (props, omitKeys = [], defaults = {}) => {\n  let keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  for (const key of keys) {\n    const value = props[key];\n\n    if (!is.und(value) && !omitKeys.includes(key)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\n/** Merge the default props of an update into a props cache. */\n\nconst mergeDefaultProps = (defaults, props, omitKeys) => getDefaultProps(props, omitKeys, defaults);\n/** These props can have default values */\n\nconst DEFAULT_PROPS = ['pause', 'cancel', 'config', 'immediate', 'onDelayEnd', 'onProps', 'onStart', 'onChange', 'onRest'];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onDelayEnd: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onRest: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n/**\n * Extract any properties whose keys are *not* reserved for customizing your\n * animations. All hooks use this function, which means `useTransition` props\n * are reserved for `useSpring` calls, etc.\n */\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  each(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n/**\n * Clone the given `props` and move all non-reserved props\n * into the `to` prop.\n */\n\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n\n  if (to) {\n    const out = {\n      to\n    };\n    each(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n\n  return _extends({}, props);\n} // Compute the goal value, converting \"red\" to \"rgba(255, 0, 0, 1)\" in the process\n\nfunction computeGoal(value) {\n  const config = getFluidConfig(value);\n  return config ? computeGoal(config.get()) : is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\n\n/**\n * This function sets a timeout if both the `delay` prop exists and\n * the `cancel` prop is not `true`.\n *\n * The `actions.start` function must handle the `cancel` prop itself,\n * but the `pause` prop is taken care of.\n */\nfunction scheduleProps(callId, {\n  key,\n  props,\n  state,\n  actions\n}) {\n  return new Promise((resolve, reject) => {\n    let delay;\n    let timeout;\n    let pause = false;\n    let cancel = matchProp(props.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      delay = callProp(props.delay || 0, key);\n      pause = matchProp(props.pause, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      timeout.cancel(); // Cache the remaining delay.\n\n      delay = timeout.time - Globals.now();\n    }\n\n    function onResume() {\n      if (delay > 0) {\n        state.pauseQueue.add(onPause);\n        timeout = Globals.frameLoop.setTimeout(onStart, delay);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      state.pauseQueue.delete(onPause); // Maybe cancelled during its delay.\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends(_extends({}, props), {}, {\n          callId,\n          delay,\n          cancel,\n          pause\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\n/** @internal */\n\n/** The object given to the `onRest` prop and `start` promise. */\n\n/** The promised result of an animation. */\n\n/** @internal */\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target) : results.every(result => result.noop) ? getNoopResult(target) : getFinishedResult(target, results.every(result => result.finished));\n/** No-op results are for updates that never start an animation. */\n\nconst getNoopResult = (target, value = target.get()) => ({\n  value,\n  noop: true,\n  finished: true,\n  target\n});\nconst getFinishedResult = (target, finished, value = target.get()) => ({\n  value,\n  finished,\n  target\n});\nconst getCancelledResult = (target, value = target.get()) => ({\n  value,\n  cancelled: true,\n  target\n});\n\n/**\n * Start an async chain or an async script.\n *\n * Always call `runAsync` in the action callback of a `scheduleProps` call.\n *\n * The `T` parameter can be a set of animated values (as an object type)\n * or a primitive type for a single animated value.\n */\nasync function runAsync(to, props, state, target) {\n  if (props.pause) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to; // The default props of any `animate` calls.\n\n    const defaultProps = getDefaultProps(props, [// The `onRest` prop is only called when the `runAsync` promise is resolved.\n    'onRest']);\n    let preventBail;\n    let bail; // This promise is rejected when the animation is interrupted.\n\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject)); // Stop animating when an error is caught.\n\n    const withBailHandler = fn => (...args) => {\n      const onError = err => {\n        if (err instanceof BailSignal) {\n          bail(err); // Stop animating.\n        }\n\n        throw err;\n      };\n\n      try {\n        return fn(...args).catch(onError);\n      } catch (err) {\n        onError(err);\n      }\n    };\n\n    const bailIfEnded = bailSignal => {\n      const bailResult = // The `cancel` prop or `stop` method was used.\n      callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.\n      callId !== state.asyncId && getFinishedResult(target, false);\n\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        throw bailSignal;\n      }\n    }; // Note: This function cannot use the `async` keyword, because we want the\n    // `throw` statements to interrupt the caller.\n\n\n    const animate = withBailHandler((arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      bailIfEnded(bailSignal);\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        to: arg1\n      });\n      props.parentId = callId;\n      each(defaultProps, (value, key) => {\n        if (is.und(props[key])) {\n          props[key] = value;\n        }\n      });\n      return target.start(props).then(async result => {\n        bailIfEnded(bailSignal);\n\n        if (target.is('PAUSED')) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n\n        return result;\n      });\n    });\n    let result;\n\n    try {\n      let animating; // Async sequence\n\n      if (is.arr(to)) {\n        animating = (async queue => {\n          for (const props of queue) {\n            await animate(props);\n          }\n        })(to);\n      } // Async script\n      else if (is.fun(to)) {\n          animating = Promise.resolve(to(animate, target.stop.bind(target)));\n        }\n\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target, true); // Bail handling\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      } // Reset the async state.\n\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : undefined;\n        state.promise = parentId ? prevPromise : undefined;\n      }\n    }\n\n    if (is.fun(onRest)) {\n      batchedUpdates(() => {\n        onRest(result);\n      });\n    }\n\n    return result;\n  })();\n}\nfunction cancelAsync(state, callId) {\n  state.cancelId = callId;\n  state.asyncId = state.asyncTo = state.promise = undefined;\n}\n/** This error is thrown to signal an interrupted async animation. */\n\nclass BailSignal extends Error {\n  constructor() {\n    super('An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.');\n    this.result = void 0;\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\nlet nextId = 1;\n/**\n * A kind of `FluidValue` that manages an `AnimatedValue` node.\n *\n * Its underlying value can be accessed and even observed.\n */\n\nclass FrameValue extends FluidValue {\n  constructor(...args) {\n    super(...args);\n    this.id = nextId++;\n    this.key = void 0;\n    this._priority = 0;\n    this._children = new Set();\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n  /** Get the current value */\n\n\n  get() {\n    const node = getAnimated(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n\n\n  to(...args) {\n    return to$1(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n\n\n  interpolate(...args) {\n    deprecateInterpolate();\n    return to$1(this, args);\n  }\n  /** @internal */\n\n\n  /** @internal */\n  addChild(child) {\n    if (!this._children.size) this._attach();\n\n    this._children.add(child);\n  }\n  /** @internal */\n\n\n  removeChild(child) {\n    this._children.delete(child);\n\n    if (!this._children.size) this._detach();\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (this.idle) {\n      // Start animating when a parent does.\n      if (type == 'start') {\n        this._reset();\n\n        this._start();\n      }\n    } // Reset our animation state when a parent does, but only when\n    // our animation is active.\n    else if (type == 'reset') {\n        this._reset();\n      }\n  }\n  /** Called when the first child is added. */\n\n\n  _attach() {}\n  /** Called when the last child is removed. */\n\n\n  _detach() {}\n  /**\n   * Reset our animation state (eg: start values, velocity, etc)\n   * and tell our children to do the same.\n   *\n   * This is called when our goal value is changed during (or before)\n   * an animation.\n   */\n\n\n  _reset() {\n    this._emit({\n      type: 'reset',\n      parent: this\n    });\n  }\n  /**\n   * Start animating if possible.\n   *\n   * Note: Be sure to call `_reset` first, or the animation will break.\n   * This method would like to call `_reset` for you, but that would\n   * interfere with paused animations.\n   */\n\n\n  _start() {\n    this._emit({\n      type: 'start',\n      parent: this\n    });\n  }\n  /** Tell our children about our new value */\n\n\n  _onChange(value, idle = false) {\n    this._emit({\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n  /** Tell our children about our new priority */\n\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      // Make the frameloop aware of our new priority.\n      frameLoop.start(this);\n    }\n\n    this._emit({\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n\n  _emit(event) {\n    // Clone \"_children\" so it can be safely mutated inside the loop.\n    each(Array.from(this._children), child => {\n      child.onParentChange(event);\n    });\n  }\n\n}\n\n// TODO: use \"const enum\" when Babel supports it\n\n/** The spring has not animated yet */\nconst CREATED = 'CREATED';\n/** The spring has animated before */\n\nconst IDLE = 'IDLE';\n/** The spring is animating */\n\nconst ACTIVE = 'ACTIVE';\n/** The spring is frozen in time */\n\nconst PAUSED = 'PAUSED';\n/** The spring cannot be animated */\n\nconst DISPOSED = 'DISPOSED';\n\n/**\n * Only numbers, strings, and arrays of numbers/strings are supported.\n * Non-animatable strings are also supported.\n */\nclass SpringValue extends FrameValue {\n  /** The property name used when `to` or `from` is an object. Useful when debugging too. */\n\n  /** The animation state */\n\n  /** The queue of pending props */\n\n  /** The lifecycle phase of this spring */\n\n  /** The state for `runAsync` calls */\n\n  /** Some props have customizable default values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The last `scheduleProps` call that changed the `to` prop */\n  constructor(arg1, arg2) {\n    super();\n    this.key = void 0;\n    this.animation = new Animation();\n    this.queue = void 0;\n    this._phase = CREATED;\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._defaultProps = {};\n    this._lastCallId = 0;\n    this._lastToId = 0;\n\n    if (!is.und(arg1) || !is.und(arg2)) {\n      const props = is.obj(arg1) ? _extends({}, arg1) : _extends(_extends({}, arg2), {}, {\n        from: arg1\n      });\n      props.default = true;\n      this.start(props);\n    }\n  }\n\n  get idle() {\n    return !this.is(ACTIVE) && !this._state.asyncTo;\n  }\n\n  get goal() {\n    return getFluidValue(this.animation.to);\n  }\n\n  get velocity() {\n    const node = getAnimated(this);\n    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n  /** Advance the current animation by a number of milliseconds */\n\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = getPayload(anim.to);\n\n    if (!payload) {\n      const toConfig = getFluidConfig(anim.to);\n\n      if (toConfig) {\n        toValues = toArray(toConfig.get());\n      }\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return; // The \"anim.toValues\" array must exist when no parent exists.\n\n      let to = payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n\n      if (!finished) {\n        position = node.lastPosition; // Loose springs never move.\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n\n        const elapsed = node.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node.v0 != null ? node.v0 : node.v0 = is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity; // Duration easing\n\n        if (!is.und(config.duration)) {\n          let p = config.progress || 0;\n          if (config.duration <= 0) p = 1;else p += (1 - p) * Math.min(1, elapsed / config.duration);\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } // Decay easing\n        else if (config.decay) {\n            const decay = config.decay === true ? 0.998 : config.decay;\n            const e = Math.exp(-(1 - decay) * elapsed);\n            position = from + v0 / (1 - decay) * (1 - e);\n            finished = Math.abs(node.lastPosition - position) < 0.1; // derivative of position\n\n            velocity = v0 * e;\n          } // Spring easing\n          else {\n              velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n              /** The smallest distance from a value before being treated like said value. */\n\n              const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n              /** The velocity at which movement is essentially none */\n\n              const restVelocity = config.restVelocity || precision / 10; // Bouncing is opt-in (not to be confused with overshooting)\n\n              const bounceFactor = config.clamp ? 0 : config.bounce;\n              const canBounce = !is.und(bounceFactor);\n              /** When `true`, the value is increasing over time */\n\n              const isGrowing = from == to ? node.v0 > 0 : from < to;\n              /** When `true`, the velocity is considered moving */\n\n              let isMoving;\n              /** When `true`, the velocity is being deflected or clamped */\n\n              let isBouncing = false;\n              const step = 1; // 1ms\n\n              const numSteps = Math.ceil(dt / step);\n\n              for (let n = 0; n < numSteps; ++n) {\n                isMoving = Math.abs(velocity) > restVelocity;\n\n                if (!isMoving) {\n                  finished = Math.abs(to - position) <= precision;\n\n                  if (finished) {\n                    break;\n                  }\n                }\n\n                if (canBounce) {\n                  isBouncing = position == to || position > to == isGrowing; // Invert the velocity with a magnitude, or clamp it.\n\n                  if (isBouncing) {\n                    velocity = -velocity * bounceFactor;\n                    position = to;\n                  }\n                }\n\n                const springForce = -config.tension * 0.000001 * (position - to);\n                const dampingForce = -config.friction * 0.001 * velocity;\n                const acceleration = (springForce + dampingForce) / config.mass; // pt/ms^2\n\n                velocity = velocity + acceleration * step; // pt/ms\n\n                position = position + velocity * step;\n              }\n            }\n\n        node.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(\"Got NaN while animating:\", this);\n          finished = true;\n        }\n      } // Parent springs must finish before their children can.\n\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n\n    if (idle) {\n      this.finish();\n    } else if (changed) {\n      this._onChange(this.get());\n    }\n\n    return idle;\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Set the current value, while stopping the current animation */\n\n\n  set(value) {\n    batchedUpdates(() => {\n      this._focus(value);\n\n      if (this._set(value)) {\n        // Ensure change observers are notified. When active,\n        // the \"_stop\" method handles this.\n        if (!this.is(ACTIVE)) {\n          return this._onChange(this.get(), true);\n        }\n      }\n\n      this._stop();\n    });\n    return this;\n  }\n  /**\n   * Freeze the active animation in time.\n   * This does nothing when not animating.\n   */\n\n\n  pause() {\n    checkDisposed(this, 'pause');\n\n    if (!this.is(PAUSED)) {\n      this._phase = PAUSED;\n      flush(this._state.pauseQueue, onPause => onPause());\n    }\n  }\n  /** Resume the animation if paused. */\n\n\n  resume() {\n    checkDisposed(this, 'resume');\n\n    if (this.is(PAUSED)) {\n      this._start();\n\n      flush(this._state.resumeQueue, onResume => onResume());\n    }\n  }\n  /**\n   * Skip to the end of the current animation.\n   *\n   * All `onRest` callbacks are passed `{finished: true}`\n   */\n\n\n  finish(to) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      const anim = this.animation; // Decay animations have an implicit goal.\n\n      if (!anim.config.decay && is.und(to)) {\n        to = anim.to;\n      } // Set the value if we can.\n\n\n      if (!is.und(to)) {\n        this._set(to);\n      }\n\n      batchedUpdates(() => {\n        // Ensure the \"onStart\" and \"onRest\" props are called.\n        if (!anim.changed) {\n          anim.changed = true;\n\n          if (anim.onStart) {\n            anim.onStart(this);\n          }\n        } // Exit the frameloop.\n\n\n        this._stop();\n      });\n    }\n\n    return this;\n  }\n  /** Push props into the pending queue. */\n\n\n  update(props) {\n    checkDisposed(this, 'update');\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  /**\n   * Update this value's animation using the queue of pending props,\n   * and unpause the current animation (if one is frozen).\n   *\n   * When arguments are passed, a new animation is created, and the\n   * queued animations are left alone.\n   */\n\n\n  async start(to, arg2) {\n    checkDisposed(this, 'start');\n    let queue;\n\n    if (!is.und(to)) {\n      queue = [is.obj(to) ? to : _extends(_extends({}, arg2), {}, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    const results = await Promise.all(queue.map(props => this._update(props)));\n    return getCombinedResult(this, results);\n  }\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n\n\n  stop(cancel) {\n    if (!this.is(DISPOSED)) {\n      cancelAsync(this._state, this._lastCallId); // Ensure the `to` value equals the current value.\n\n      this._focus(this.get()); // Exit the frameloop and notify `onRest` listeners.\n\n\n      batchedUpdates(() => this._stop(cancel));\n    }\n\n    return this;\n  }\n  /** Restart the animation. */\n\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n  /** Prevent future animations, and stop the current animation */\n\n\n  dispose() {\n    if (!this.is(DISPOSED)) {\n      if (this.animation) {\n        // Prevent \"onRest\" calls when disposed.\n        this.animation.onRest = [];\n      }\n\n      this.stop();\n      this._phase = DISPOSED;\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    super.onParentChange(event);\n\n    if (event.type == 'change') {\n      if (!this.is(ACTIVE)) {\n        this._reset();\n\n        if (!this.is(PAUSED)) {\n          this._start();\n        }\n      }\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n\n\n  _prepareNode({\n    to,\n    from,\n    reverse\n  }) {\n    const key = this.key || '';\n    to = !is.obj(to) || getFluidConfig(to) ? to : to[key];\n    from = !is.obj(from) || getFluidConfig(from) ? from : from[key]; // Create the range now to avoid \"reverse\" logic.\n\n    const range = {\n      to,\n      from\n    }; // Before ever animating, this method ensures an `Animated` node\n    // exists and keeps its value in sync with the \"from\" prop.\n\n    if (this.is(CREATED)) {\n      if (reverse) [to, from] = [from, to];\n      from = getFluidValue(from);\n\n      const node = this._updateNode(is.und(from) ? getFluidValue(to) : from);\n\n      if (node && !is.und(from)) {\n        node.setValue(from);\n      }\n    }\n\n    return range;\n  }\n  /**\n   * Create an `Animated` node if none exists or the given value has an\n   * incompatible type. Do nothing if `value` is undefined.\n   *\n   * The newest `Animated` node is returned.\n   */\n\n\n  _updateNode(value) {\n    let node = getAnimated(this);\n\n    if (!is.und(value)) {\n      const nodeType = this._getNodeType(value);\n\n      if (!node || node.constructor !== nodeType) {\n        setAnimated(this, node = nodeType.create(value));\n      }\n    }\n\n    return node;\n  }\n  /** Return the `Animated` node constructor for a given value */\n\n\n  _getNodeType(value) {\n    const parentNode = getAnimated(value);\n    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  }\n  /** Schedule an animation to run after an optional delay */\n\n\n  _update(props, isLoop) {\n    const defaultProps = this._defaultProps;\n\n    const mergeDefaultProp = key => {\n      const value = getDefaultProp(props, key);\n\n      if (!is.und(value)) {\n        defaultProps[key] = value;\n      } // For `cancel` and `pause`, a truthy default always wins.\n\n\n      if (defaultProps[key]) {\n        props[key] = defaultProps[key];\n      }\n    }; // These props are coerced into booleans by the `scheduleProps` function,\n    // so they need their default values processed before then.\n\n\n    mergeDefaultProp('cancel');\n    mergeDefaultProp('pause'); // Ensure the initial value can be accessed by animated components.\n\n    const range = this._prepareNode(props);\n\n    return scheduleProps(++this._lastCallId, {\n      key: this.key,\n      props,\n      state: this._state,\n      actions: {\n        pause: this.pause.bind(this),\n        resume: this.resume.bind(this),\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n  /** Merge props into the current animation */\n\n\n  _merge(range, props, resolve) {\n    // The \"cancel\" prop cancels all pending delays and it forces the\n    // active animation to stop where it is.\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    const {\n      key,\n      animation: anim\n    } = this;\n    const defaultProps = this._defaultProps;\n    /** The \"to\" prop is defined. */\n\n    const hasToProp = !is.und(range.to);\n    /** The \"from\" prop is defined. */\n\n    const hasFromProp = !is.und(range.from); // Avoid merging other props if implicitly prevented, except\n    // when both the \"to\" and \"from\" props are undefined.\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    /** Get the value of a prop, or its default value */\n\n\n    const get = prop => !is.und(props[prop]) ? props[prop] : defaultProps[prop]; // Call \"onDelayEnd\" before merging props, but after cancellation checks.\n\n\n    const onDelayEnd = coerceEventProp(get('onDelayEnd'), key);\n\n    if (onDelayEnd) {\n      onDelayEnd(props, this);\n    }\n\n    if (props.default) {\n      mergeDefaultProps(defaultProps, props, ['pause', 'cancel']);\n    }\n\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range; // Focus the \"from\" value if changing without a \"to\" value.\n\n    if (hasFromProp && !hasToProp) {\n      to = from;\n    } // Flip the current range if \"reverse\" is true.\n\n\n    if (props.reverse) [to, from] = [from, to];\n    /** The \"from\" value is changing. */\n\n    const hasFromChanged = !isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    /** The \"to\" value is changing. */\n\n\n    const hasToChanged = !isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    } // Both \"from\" and \"to\" can use a fluid config (thanks to http://npmjs.org/fluids).\n\n\n    const toConfig = getFluidConfig(to);\n    const fromConfig = getFluidConfig(from);\n\n    if (fromConfig) {\n      from = fromConfig.get();\n    }\n    /** The \"to\" prop is async. */\n\n\n    const hasAsyncTo = is.arr(props.to) || is.fun(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config; // The \"runAsync\" function treats the \"config\" prop as a default,\n    // so we must avoid merging it when the \"to\" prop is async.\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), // Avoid calling the same \"config\" prop twice.\n      props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    } // This instance might not have its Animated node yet. For example,\n    // the constructor can be given props without a \"to\" or \"from\" value.\n\n\n    let node = getAnimated(this);\n\n    if (!node || is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    /** When true, start at the \"from\" value. */\n\n\n    const reset = // When `reset` is undefined, the `from` prop implies `reset: true`,\n    // except for declarative updates. When `reset` is defined, there\n    // must exist a value to animate from.\n    is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key); // The current value, where the animation starts from.\n\n    const value = reset ? from : this.get(); // The animation ends at this value, unless \"to\" is fluid.\n\n    const goal = computeGoal(to); // Only specific types can be animated to/from.\n\n    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal); // When true, the value changes instantly on the next frame.\n\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      if (immediate) {\n        node = this._updateNode(goal);\n      } else {\n        const nodeType = this._getNodeType(to);\n\n        if (nodeType !== node.constructor) {\n          throw Error(\"Cannot animate between \" + node.constructor.name + \" and \" + nodeType.name + \", as the \\\"to\\\" prop suggests\");\n        }\n      }\n    } // The type of Animated node for the goal value.\n\n\n    const goalType = node.constructor; // When the goal value is fluid, we don't know if its value\n    // will change before the next animation frame, so it always\n    // starts the animation to be safe.\n\n    let started = !!toConfig;\n    let finished = false;\n\n    if (!started) {\n      // When true, the current value has probably changed.\n      const hasValueChanged = reset || this.is(CREATED) && hasFromChanged; // When the \"to\" value or current value are changed,\n      // start animating if not already finished.\n\n      if (hasToChanged || hasValueChanged) {\n        finished = isEqual(computeGoal(value), goal);\n        started = !finished;\n      } // Changing \"decay\" or \"velocity\" starts the animation.\n\n\n      if (!isEqual(config.decay, decay) || !isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    } // When an active animation changes its goal to its current value:\n\n\n    if (finished && this.is(ACTIVE)) {\n      // Avoid an abrupt stop unless the animation is being reset.\n      if (anim.changed && !reset) {\n        started = true;\n      } // Stop the animation before its first frame.\n      else if (!started) {\n          this._stop();\n        }\n    }\n\n    if (!hasAsyncTo) {\n      // Make sure our \"toValues\" are updated even if our previous\n      // \"to\" prop is a fluid value whose current value is also ours.\n      if (started || getFluidConfig(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = toConfig ? null : goalType == AnimatedString ? [1] : toArray(goal);\n      }\n\n      anim.immediate = immediate;\n      anim.onStart = coerceEventProp(get('onStart'), key);\n      anim.onChange = coerceEventProp(get('onChange'), key); // The \"reset\" prop tries to reuse the old \"onRest\" prop,\n      // unless you defined a new \"onRest\" prop.\n\n      const onRestQueue = anim.onRest;\n      const onRest = reset && !props.onRest ? onRestQueue[0] || noop : checkFinishedOnRest(coerceEventProp(get('onRest'), key), this); // In most cases, the animation after this one won't reuse our\n      // \"onRest\" prop. Instead, the _default_ \"onRest\" prop is used\n      // when the next animation has an undefined \"onRest\" prop.\n\n      if (started) {\n        anim.onRest = [onRest, checkFinishedOnRest(resolve, this)]; // Flush the \"onRest\" queue for the previous animation.\n\n        let onRestIndex = reset ? 0 : 1;\n\n        if (onRestIndex < onRestQueue.length) {\n          batchedUpdates(() => {\n            for (; onRestIndex < onRestQueue.length; onRestIndex++) {\n              onRestQueue[onRestIndex]();\n            }\n          });\n        }\n      } // The \"onRest\" prop is always first, and it can be updated even\n      // if a new animation is not started by this update.\n      else if (reset || props.onRest) {\n          anim.onRest[0] = onRest;\n        }\n    } // By this point, every prop has been merged.\n\n\n    const onProps = coerceEventProp(get('onProps'), key);\n\n    if (onProps) {\n      onProps(props, this);\n    } // Update our node even if the animation is idle.\n\n\n    if (reset) {\n      node.setValue(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } // Start an animation\n    else if (started) {\n        // Must be idle for \"onStart\" to be called again.\n        if (reset) this._phase = IDLE;\n\n        this._reset();\n\n        this._start();\n      } // Postpone promise resolution until the animation is finished,\n      // so that no-op updates still resolve at the expected time.\n      else if (this.is(ACTIVE) && !hasToChanged) {\n          anim.onRest.push(checkFinishedOnRest(resolve, this));\n        } // Resolve our promise immediately.\n        else {\n            resolve(getNoopResult(this, value));\n          }\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n\n\n  _focus(value) {\n    const anim = this.animation;\n\n    if (value !== anim.to) {\n      let config = getFluidConfig(anim.to);\n\n      if (config) {\n        config.removeChild(this);\n      }\n\n      anim.to = value;\n      let priority = 0;\n\n      if (config = getFluidConfig(value)) {\n        config.addChild(this);\n\n        if (isFrameValue(value)) {\n          priority = (value.priority || 0) + 1;\n        }\n      }\n\n      this.priority = priority;\n    }\n  }\n  /** Set the current value and our `node` if necessary. The `_onChange` method is *not* called. */\n\n\n  _set(value) {\n    const config = getFluidConfig(value);\n\n    if (config) {\n      value = config.get();\n    }\n\n    const node = getAnimated(this);\n    const oldValue = node && node.getValue();\n\n    if (node) {\n      node.setValue(value);\n    } else {\n      this._updateNode(value);\n    }\n\n    return !isEqual(value, oldValue);\n  }\n\n  _onChange(value, idle = false) {\n    const anim = this.animation; // The \"onStart\" prop is called on the first change after entering the\n    // frameloop, but never for immediate animations.\n\n    if (!anim.changed && !idle) {\n      anim.changed = true;\n\n      if (anim.onStart) {\n        anim.onStart(this);\n      }\n    }\n\n    if (anim.onChange) {\n      anim.onChange(value, this);\n    }\n\n    super._onChange(value, idle);\n  }\n\n  _reset() {\n    const anim = this.animation; // Reset the state of each Animated node.\n\n    getAnimated(this).reset(anim.to); // Ensure the `onStart` prop will be called.\n\n    if (!this.is(ACTIVE)) {\n      anim.changed = false;\n    } // Use the current values as the from values.\n\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n\n    super._reset();\n  }\n\n  _start() {\n    if (!this.is(ACTIVE)) {\n      this._phase = ACTIVE;\n\n      super._start(); // The \"skipAnimation\" global avoids the frameloop.\n\n\n      if (skipAnimation) {\n        this.finish();\n      } else {\n        frameLoop.start(this);\n      }\n    }\n  }\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n\n\n  _stop(cancel) {\n    this.resume();\n\n    if (this.is(ACTIVE)) {\n      this._phase = IDLE; // Always let change observers know when a spring becomes idle.\n\n      this._onChange(this.get(), true);\n\n      const anim = this.animation;\n      each(anim.values, node => {\n        node.done = true;\n      });\n      const onRestQueue = anim.onRest;\n\n      if (onRestQueue.length) {\n        // Preserve the \"onRest\" prop when the goal is dynamic.\n        anim.onRest = [anim.toValues ? noop : onRestQueue[0]]; // Never call the \"onRest\" prop for no-op animations.\n\n        if (!anim.changed) {\n          onRestQueue[0] = noop;\n        }\n\n        each(onRestQueue, onRest => onRest(cancel));\n      }\n    }\n  }\n\n}\n\nfunction checkDisposed(spring, name) {\n  if (spring.is(DISPOSED)) {\n    throw Error(\"Cannot call \\\"\" + name + \"\\\" of disposed \\\"\" + spring.constructor.name + \"\\\" object\");\n  }\n}\n/** Coerce an event prop to an event handler */\n\n\nfunction coerceEventProp(prop, key) {\n  return is.fun(prop) ? prop : key && prop ? prop[key] : undefined;\n}\n/**\n * The \"finished\" value is determined by each \"onRest\" handler,\n * based on whether the current value equals the goal value that\n * was calculated at the time the \"onRest\" handler was set.\n */\n\n\nconst checkFinishedOnRest = (onRest, spring) => {\n  const {\n    to\n  } = spring.animation;\n  return onRest ? cancel => {\n    if (cancel) {\n      onRest(getCancelledResult(spring));\n    } else {\n      const goal = computeGoal(to);\n      const value = computeGoal(spring.get());\n      const finished = isEqual(value, goal);\n      onRest(getFinishedResult(spring, finished));\n    }\n  } : noop;\n};\n\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\n  let loopRet = callProp(loop);\n\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate(_extends(_extends({}, props), {}, {\n      loop,\n      // Avoid updating default props when looping.\n      default: false,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || is.arr(to) || is.fun(to) ? to : undefined,\n      // Avoid defining the \"from\" prop if a reset is unwanted.\n      from: reset ? props.from : undefined,\n      reset\n    }, overrides));\n  }\n}\n/**\n * Return a new object based on the given `props`.\n *\n * - All unreserved props are moved into the `to` prop object.\n * - The `to` and `from` props are deleted when falsy.\n * - The `keys` prop is set to an array of affected keys,\n *   or `null` if all keys are affected.\n */\n\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props); // Collect the keys affected by this update.\n\n  const keys = new Set();\n\n  if (from) {\n    findDefined(from, keys);\n  } else {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.from;\n  }\n\n  if (is.obj(to)) {\n    findDefined(to, keys);\n  } else if (!to) {\n    // Falsy values are deleted to avoid merging issues.\n    delete props.to;\n  } // The \"keys\" prop helps in applying updates to affected keys only.\n\n\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\n/**\n * A modified version of `createUpdate` meant for declarative APIs.\n */\n\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n\n  if (is.und(update.default)) {\n    update.default = getDefaultProps(update, [// Avoid forcing `immediate: true` onto imperative updates.\n    update.immediate === true && 'immediate']);\n  }\n\n  return update;\n}\n/** Find keys with defined values */\n\nfunction findDefined(values, keys) {\n  each(values, (value, key) => value != null && keys.add(key));\n}\n\n/** Events batched by the `Controller` class */\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nlet nextId$1 = 1;\n/** Queue of pending updates for a `Controller` instance. */\n\nclass Controller {\n  /** The animated values */\n\n  /** The queue of props passed to the `update` method. */\n\n  /** Custom handler for flushing update queues */\n\n  /** These props are used by all future spring values */\n\n  /** The combined phase of our spring values */\n\n  /** The counter for tracking `scheduleProps` calls */\n\n  /** The values currently being animated */\n\n  /** State used by the `runAsync` function */\n\n  /** The event queues that are flushed once per frame maximum */\n  constructor(props, flush) {\n    this.id = nextId$1++;\n    this.springs = {};\n    this.queue = [];\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._phase = CREATED;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._state = {\n      pauseQueue: new Set(),\n      resumeQueue: new Set()\n    };\n    this._events = {\n      onStart: new Set(),\n      onChange: new Set(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(props);\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => spring.idle);\n  }\n  /** Check the current phase */\n\n\n  is(phase) {\n    return this._phase == phase;\n  }\n  /** Get the current values of our springs */\n\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n  /** Push an update onto the queue of each value. */\n\n\n  update(props) {\n    if (props) this.queue.push(createUpdate(props));\n    return this;\n  }\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n\n\n  start(props) {\n    const queue = props ? toArray(props).map(createUpdate) : this.queue;\n\n    if (!props) {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  /** Stop one animation, some animations, or all animations */\n\n\n  stop(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.stop());\n      cancelAsync(this._state, this._lastAsyncId);\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].stop());\n    }\n\n    return this;\n  }\n  /** Freeze the active animation in time */\n\n\n  pause(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.pause());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].pause());\n    }\n\n    return this;\n  }\n  /** Resume the animation if paused. */\n\n\n  resume(keys) {\n    if (is.und(keys)) {\n      this.each(spring => spring.resume());\n    } else {\n      const springs = this.springs;\n      each(toArray(keys), key => springs[key].resume());\n    }\n\n    return this;\n  }\n  /** Restart every animation. */\n\n\n  reset() {\n    this.each(spring => spring.reset()); // TODO: restart async \"to\" prop\n\n    return this;\n  }\n  /** Call a function once per spring value */\n\n\n  each(iterator) {\n    each(this.springs, iterator);\n  }\n  /** Destroy every spring in this controller */\n\n\n  dispose() {\n    this._state.asyncTo = undefined;\n    this.each(spring => spring.dispose());\n    this.springs = {};\n  }\n  /** @internal Called at the end of every animation frame */\n\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const isActive = this._active.size > 0;\n\n    if (isActive && this._phase != ACTIVE) {\n      this._phase = ACTIVE;\n      flush(onStart, onStart => onStart(this));\n    }\n\n    const values = (onChange.size || !isActive && onRest.size) && this.get();\n    flush(onChange, onChange => onChange(values)); // The \"onRest\" queue is only flushed when all springs are idle.\n\n    if (!isActive) {\n      this._phase = IDLE;\n      flush(onRest, ([onRest, result]) => {\n        result.value = values;\n        onRest(result);\n      });\n    }\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    if (event.type == 'change') {\n      this._active[event.idle ? 'delete' : 'add'](event.parent);\n\n      frameLoop.onFrame(this._onFrame);\n    }\n  }\n\n}\n/**\n * Warning: Props might be mutated.\n */\n\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\n/**\n * Warning: Props might be mutated.\n *\n * Process a single set of props using the given controller.\n *\n * The returned promise resolves to `true` once the update is\n * applied and any animations it starts are finished without being\n * stopped or cancelled.\n */\n\nfunction flushUpdate(ctrl, props, isLoop) {\n  const {\n    to,\n    loop,\n    onRest\n  } = props; // Looping must be handled in this function, or else the values\n  // would end up looping out-of-sync in many common cases.\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  const asyncTo = is.arr(to) || is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n  } else {\n    // For certain events, use batching to prevent multiple calls per frame.\n    // However, batching is avoided when the `to` prop is async, because any\n    // event props are used as default props instead.\n    each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n\n      if (is.fun(handler)) {\n        const queue = ctrl['_events'][key];\n\n        if (queue instanceof Set) {\n          props[key] = () => queue.add(handler);\n        } else {\n          props[key] = ({\n            finished,\n            cancelled\n          }) => {\n            const result = queue.get(handler);\n\n            if (result) {\n              if (!finished) result.finished = false;\n              if (cancelled) result.cancelled = true;\n            } else {\n              // The \"value\" is set before the \"handler\" is called.\n              queue.set(handler, {\n                value: null,\n                finished,\n                cancelled\n              });\n            }\n          };\n        }\n      }\n    });\n  }\n\n  const keys = props.keys || Object.keys(ctrl.springs);\n  const promises = keys.map(key => ctrl.springs[key].start(props)); // Schedule the \"asyncTo\" if defined.\n\n  const state = ctrl['_state'];\n\n  if (asyncTo) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props,\n      state,\n      actions: {\n        pause: noop,\n        resume: noop,\n\n        start(props, resolve) {\n          props.onRest = onRest;\n\n          if (!props.cancel) {\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          } // Prevent `cancel: true` from ending the current `runAsync` call,\n          // except when the default `cancel` prop is being set.\n          else if (hasDefaultProp(props, 'cancel')) {\n              cancelAsync(state, props.callId);\n            }\n        }\n\n      }\n    }));\n  } // Respect the `cancel` prop when no keys are affected.\n  else if (!props.keys && props.cancel === true) {\n      cancelAsync(state, ctrl['_lastAsyncId']);\n    }\n\n  return Promise.all(promises).then(results => {\n    const result = getCombinedResult(ctrl, results);\n\n    if (loop && result.finished && !(isLoop && result.noop)) {\n      const nextProps = createLoopUpdate(props, loop, to);\n\n      if (nextProps) {\n        prepareKeys(ctrl, [nextProps]);\n        return flushUpdate(ctrl, nextProps, true);\n      }\n    }\n\n    return result;\n  });\n}\n/**\n * From an array of updates, get the map of `SpringValue` objects\n * by their keys. Springs are created when any update wants to\n * animate a new key.\n *\n * Springs created by `getSprings` are neither cached nor observed\n * until they're given to `setSprings`.\n */\n\nfunction getSprings(ctrl, props) {\n  const springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    each(toArray(props), props => {\n      if (is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!is.obj(props.to)) {\n        // Avoid passing array/function to each spring.\n        props = _extends(_extends({}, props), {}, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, key => {\n        return createSpring(key);\n      });\n    });\n  }\n\n  return springs;\n}\n/**\n * Tell a controller to manage the given `SpringValue` objects\n * whose key is not already in use.\n */\n\nfunction setSprings(ctrl, springs) {\n  each(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      spring.addChild(ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    spring.addChild(observer);\n  }\n\n  return spring;\n}\n/**\n * Ensure spring objects exist for each defined key.\n *\n * Using the `props`, the `Animated` node of each `SpringValue` may\n * be created or updated.\n */\n\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n/**\n * Ensure spring objects exist for each defined key, and attach the\n * `ctrl` to them for observation.\n *\n * The queue is expected to contain `createUpdate` results.\n */\n\n\nfunction prepareKeys(ctrl, queue) {\n  each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\n/**\n * This context affects all new and existing `SpringValue` objects\n * created with the hook API or the renderprops API.\n */\n\nconst ctx = createContext({});\nconst SpringContext = (_ref) => {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  const inherited = useContext(ctx); // Memoize the context to avoid unwanted renders.\n\n  props = useMemo(() => _extends(_extends({}, inherited), props), [inherited, props.pause, props.cancel, props.immediate, props.config]);\n  const {\n    Provider\n  } = ctx;\n  return /*#__PURE__*/createElement(Provider, {\n    value: props\n  }, children);\n};\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n/** Get the current values of nearest `SpringContext` component. */\n\nconst useSpringContext = () => useContext(ctx);\n\n/** Create an imperative API for manipulating an array of `Controller` objects. */\nconst SpringHandle = {\n  create: getControllers => ({\n    get controllers() {\n      return getControllers();\n    },\n\n    update(props) {\n      each(getControllers(), (ctrl, i) => {\n        ctrl.update(getProps(props, i, ctrl));\n      });\n      return this;\n    },\n\n    async start(props) {\n      const results = await Promise.all(getControllers().map((ctrl, i) => {\n        const update = getProps(props, i, ctrl);\n        return ctrl.start(update);\n      }));\n      return {\n        value: results.map(result => result.value),\n        finished: results.every(result => result.finished)\n      };\n    },\n\n    stop: keys => each(getControllers(), ctrl => ctrl.stop(keys)),\n    pause: keys => each(getControllers(), ctrl => ctrl.pause(keys)),\n    resume: keys => each(getControllers(), ctrl => ctrl.resume(keys))\n  })\n};\n\n/** @internal */\nfunction useSprings(length, props, deps) {\n  const propsFn = is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  // Set to 0 to prevent sync flush.\n  const layoutId = useRef(0);\n  const forceUpdate = useForceUpdate(); // State is updated on commit.\n\n  const [state] = useState(() => ({\n    ctrls: [],\n    queue: [],\n\n    flush(ctrl, updates) {\n      const springs = getSprings(ctrl, updates); // Flushing is postponed until the component's commit phase\n      // if a spring was created since the last commit.\n\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(resolve => {\n        setSprings(ctrl, springs);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates));\n        });\n        forceUpdate();\n      });\n    }\n\n  })); // The imperative API ref from the props of the first controller.\n\n  const refProp = useRef();\n  const ctrls = [...state.ctrls];\n  const updates = []; // Cache old controllers to dispose in the commit phase.\n\n  const prevLength = usePrev(length) || 0;\n  const disposed = ctrls.slice(length, prevLength); // Create new controllers when \"length\" increases, and destroy\n  // the affected controllers when \"length\" decreases.\n\n  useMemo(() => {\n    ctrls.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]); // Update existing controllers when \"deps\" are changed.\n\n  useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  /** Fill the `updates` array with declarative updates for the given index range. */\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls[i] || (ctrls[i] = new Controller(null, state.flush));\n      let update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        update = updates[i] = declareUpdate(update);\n\n        if (i == 0) {\n          refProp.current = update.ref;\n          update.ref = undefined;\n        }\n      }\n    }\n  }\n\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => state.ctrls);\n  }, []); // New springs are created during render so users can pass them to\n  // their animated components, but new springs aren't cached until the\n  // commit phase (see the `useLayoutEffect` callback below).\n\n  const springs = ctrls.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = useSpringContext();\n  useLayoutEffect(() => {\n    layoutId.current++; // Replace the cached controllers.\n\n    state.ctrls = ctrls; // Update the ref prop.\n\n    if (refProp.current) {\n      refProp.current.current = api;\n    } // Flush the commit queue.\n\n\n    const {\n      queue\n    } = state;\n\n    if (queue.length) {\n      state.queue = [];\n      each(queue, cb => cb());\n    } // Dispose unused controllers.\n\n\n    each(disposed, ctrl => ctrl.dispose()); // Update existing controllers.\n\n    each(ctrls, (ctrl, i) => {\n      const values = springs[i];\n      setSprings(ctrl, values); // Update the default props.\n\n      ctrl.start({\n        default: context\n      }); // Apply updates created during render.\n\n      const update = updates[i];\n\n      if (update) {\n        // Start animating unless a ref exists.\n        if (refProp.current) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  }); // Dispose all controllers on unmount.\n\n  useOnce(() => () => {\n    each(state.ctrls, ctrl => ctrl.dispose());\n  }); // Return a deep copy of the `springs` array so the caller can\n  // safely mutate it during render.\n\n  const values = springs.map(x => _extends({}, x));\n  return propsFn || arguments.length == 3 ? [values, api.start, api.stop] : values;\n}\n\n/**\n * The props that `useSpring` recognizes.\n */\n\n/** @internal */\nfunction useSpring(props, deps) {\n  const isFn = is.fun(props);\n  const [[values], update, stop] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, update, stop] : values;\n}\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  const ctrls = [];\n  const result = useSprings(length, (i, ctrl) => {\n    ctrls[i] = ctrl;\n    return getProps(propsArg, i, ctrl);\n  }, // Ensure the props function is called when no deps exist.\n  // This works around the 3 argument rule.\n  deps || [{}]);\n  useLayoutEffect(() => {\n    const reverse = is.obj(propsArg) && propsArg.reverse;\n\n    for (let i = 0; i < ctrls.length; i++) {\n      const parent = ctrls[i + (reverse ? 1 : -1)];\n      if (parent) ctrls[i].update({\n        to: parent.springs\n      }).start();\n    }\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    const update = result[1];\n    result[1] = useCallbackOne(propsArg => {\n      const reverse = is.obj(propsArg) && propsArg.reverse;\n      return update((i, ctrl) => {\n        const props = getProps(propsArg, i, ctrl);\n        const parent = ctrls[i + (reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      });\n    }, deps);\n    return result;\n  }\n\n  return result[0];\n}\n\n// TODO: convert to \"const enum\" once Babel supports it\n\n/** This transition is being mounted */\nconst MOUNT = 'mount';\n/** This transition is entering or has entered */\n\nconst ENTER = 'enter';\n/** This transition had its animations updated */\n\nconst UPDATE = 'update';\n/** This transition will expire after animating */\n\nconst LEAVE = 'leave';\n\nfunction useTransition(data, props, deps) {\n  const {\n    ref,\n    reset,\n    sort,\n    trail = 0,\n    expires = true\n  } = props; // Every item has its own transition.\n\n  const items = toArray(data);\n  const transitions = []; // Keys help with reusing transitions between renders.\n  // The `key` prop can be undefined (which means the items themselves are used\n  // as keys), or a function (which maps each item to its key), or an array of\n  // keys (which are assigned to each item by index).\n\n  const keys = getKeys(items, props); // The \"onRest\" callbacks need a ref to the latest transitions.\n\n  const usedTransitions = useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  useLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  }); // Destroy all transitions on dismount.\n\n  useOnce(() => () => each(usedTransitions.current, t => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    }\n\n    t.ctrl.dispose();\n  })); // Map old indices to new indices.\n\n  const reused = [];\n  if (prevTransitions) each(prevTransitions, (t, i) => {\n    // Expired transitions are not rendered.\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  }); // Mount new items with fresh transitions.\n\n  each(items, (item, i) => {\n    transitions[i] || (transitions[i] = {\n      key: keys[i],\n      item,\n      phase: MOUNT,\n      ctrl: new Controller()\n    });\n  }); // Update the item of any transition whose key still exists,\n  // and ensure leaving transitions are rendered until they finish.\n\n  if (reused.length) {\n    let i = -1;\n    each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends(_extends({}, t), {}, {\n          item: items[keyIndex]\n        });\n      } else if (props.leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  } // Track cumulative delay for the \"trail\" prop.\n\n\n  let delay = -trail; // Expired transitions use this to dismount.\n\n  const forceUpdate = useForceUpdate(); // These props are inherited by every phase change.\n\n  const defaultProps = getDefaultProps(props); // Generate changes to apply in useEffect.\n\n  const changes = new Map();\n  each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    let to;\n    let phase;\n\n    if (prevPhase == MOUNT) {\n      to = props.enter;\n      phase = ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != LEAVE) {\n        if (isLeave) {\n          to = props.leave;\n          phase = LEAVE;\n        } else if (to = props.update) {\n          phase = UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = props.enter;\n        phase = ENTER;\n      } else return;\n    } // When \"to\" is a function, it can return (1) an array of \"useSpring\" props,\n    // (2) an async function, or (3) an object with any \"useSpring\" props.\n\n\n    to = callProp(to, t.item, i);\n    to = is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      const config = props.config || defaultProps.config;\n      to.config = callProp(config, t.item, i);\n    } // The payload is used to update the spring props once the current render is committed.\n\n\n    const payload = _extends(_extends({}, defaultProps), {}, {\n      delay: delay += trail,\n      // This prevents implied resets.\n      reset: false\n    }, to);\n\n    if (phase == ENTER && is.und(payload.from)) {\n      // The `initial` prop is used on the first render of our parent component,\n      // as well as when `reset: true` is passed. It overrides the `from` prop\n      // when defined, and it makes `enter` instant when null.\n      const from = is.und(props.initial) || prevTransitions ? props.from : props.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    const {\n      onRest\n    } = payload;\n\n    payload.onRest = result => {\n      const transitions = usedTransitions.current;\n      const t = transitions.find(t => t.key === key);\n      if (!t) return;\n\n      if (is.fun(onRest)) {\n        onRest(result, t);\n      } // Reset the phase of a cancelled enter/leave transition, so it can\n      // retry the animation on the next render.\n\n\n      if (result.cancelled && t.phase != UPDATE) {\n        t.phase = prevPhase;\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle);\n\n        if (t.phase == LEAVE) {\n          const expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true; // Force update once the expiration delay ends.\n\n            if (!idle && expiryMs > 0) {\n              // The maximum timeout is 2^31-1\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        } // Force update once idle and expired items exist.\n\n\n        if (idle && transitions.some(t => t.expired)) {\n          forceUpdate();\n        }\n      }\n    };\n\n    const springs = getSprings(t.ctrl, payload);\n    changes.set(t, {\n      phase,\n      springs,\n      payload\n    });\n  }); // The prop overrides from an ancestor.\n\n  const context = useSpringContext(); // Merge the context into each transition.\n\n  useLayoutEffect(() => {\n    each(transitions, t => {\n      t.ctrl.start({\n        default: context\n      });\n    });\n  }, [context]);\n  const api = useMemo$1(() => {\n    return SpringHandle.create(() => {\n      return usedTransitions.current.map(t => t.ctrl);\n    });\n  }, []);\n  useImperativeHandle(ref, () => api);\n  useLayoutEffect(() => {\n    each(changes, ({\n      phase,\n      springs,\n      payload\n    }, t) => {\n      setSprings(t.ctrl, springs);\n\n      if (!context.cancel) {\n        t.phase = phase;\n\n        if (phase == ENTER) {\n          t.ctrl.start({\n            default: context\n          });\n        }\n\n        t.ctrl[ref ? 'update' : 'start'](payload);\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  const renderTransitions = render => /*#__PURE__*/createElement(Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render(_extends({}, springs), t.item, t, i);\n    return elem && elem.type ? /*#__PURE__*/createElement(elem.type, _extends({}, elem.props, {\n      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  }));\n\n  return arguments.length == 3 ? [renderTransitions, api.start, api.stop] : renderTransitions;\n}\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}) {\n  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);\n}\n\n/**\n * The `Spring` component passes `SpringValue` objects to your render prop.\n */\nfunction Spring(_ref) {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return children(useSpring(props));\n}\n\nfunction Trail(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nfunction Transition(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"items\", \"children\"]);\n\n  return /*#__PURE__*/createElement(Fragment, null, useTransition(items, props)(children));\n}\n\n/**\n * An `Interpolation` is a memoized value that's computed whenever one of its\n * `FluidValue` dependencies has its value changed.\n *\n * Other `FrameValue` objects can depend on this. For example, passing an\n * `Interpolation` as the `to` prop of a `useSpring` call will trigger an\n * animation toward the memoized value.\n */\n\nclass Interpolation extends FrameValue {\n  /** Useful for debugging. */\n\n  /** Equals false when in the frameloop */\n\n  /** The function that maps inputs values to output */\n  constructor(source, args) {\n    super();\n    this.source = source;\n    this.key = void 0;\n    this.idle = true;\n    this.calc = void 0;\n    this.calc = createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = is.arr(value) ? AnimatedArray : AnimatedValue; // Assume the computed value never changes type.\n\n    setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!isEqual(value, oldValue)) {\n      getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n  }\n\n  _get() {\n    const inputs = is.arr(this.source) ? this.source.map(node => node.get()) : toArray(this.source.get());\n    return this.calc(...inputs);\n  }\n\n  _reset() {\n    each(getPayload(this), node => node.reset());\n\n    super._reset();\n  }\n\n  _start() {\n    this.idle = false;\n\n    super._start();\n\n    if (skipAnimation) {\n      this.idle = true;\n      this.advance();\n    } else {\n      frameLoop.start(this);\n    }\n  }\n\n  _attach() {\n    // Start observing our \"source\" once we have an observer.\n    let idle = true;\n    let priority = 1;\n    each(toArray(this.source), source => {\n      if (isFrameValue(source)) {\n        if (!source.idle) idle = false;\n        priority = Math.max(priority, source.priority + 1);\n      }\n\n      source.addChild(this);\n    });\n    this.priority = priority;\n\n    if (!idle) {\n      this._reset();\n\n      this._start();\n    }\n  }\n\n  _detach() {\n    // Stop observing our \"source\" once we have no observers.\n    each(toArray(this.source), source => {\n      source.removeChild(this);\n    }); // This removes us from the frameloop.\n\n    this.idle = true;\n  }\n  /** @internal */\n\n\n  onParentChange(event) {\n    // Ensure our start value respects our parent values, in case\n    // any of their animations were restarted with the \"reset\" prop.\n    if (event.type == 'start') {\n      this.advance();\n    } // Change events are useful for (1) reacting to non-animated parents\n    // and (2) reacting to the last change in a parent animation.\n    else if (event.type == 'change') {\n        // If we're idle, we know for sure that this change is *not*\n        // caused by an animation.\n        if (this.idle) {\n          this.advance();\n        } // Leave the frameloop when all parents are done animating.\n        else if (event.idle) {\n            this.idle = toArray(this.source).every(source => source.idle !== false);\n\n            if (this.idle) {\n              this.advance();\n              each(getPayload(this), node => {\n                node.done = true;\n              });\n            }\n          }\n      } // Ensure our priority is greater than all parents, which means\n      // our value won't be updated until our parents have updated.\n      else if (event.type == 'priority') {\n          this.priority = toArray(this.source).reduce((max, source) => Math.max(max, (source.priority || 0) + 1), 0);\n        }\n\n    super.onParentChange(event);\n  }\n\n}\n\n/** Map the value of one or more dependencies */\n\nconst to = (source, ...args) => new Interpolation(source, args);\n/** @deprecated Use the `to` export instead */\n\nconst interpolate = (source, ...args) => (deprecateInterpolate(), new Interpolation(source, args));\n/** Extract the raw value types that are being interpolated */\n\nGlobals.assign({\n  createStringInterpolator: createStringInterpolator$1,\n  to: (source, args) => new Interpolation(source, args)\n});\n/** Advance all animations forward one frame */\n\nconst update = () => Globals.frameLoop.advance();\n\nexport { BailSignal, Controller, FrameValue, Interpolation, Spring, SpringContext, SpringHandle, SpringValue, Trail, Transition, config, inferTo, interpolate, to, update, useChain, useSpring, useSprings, useTrail, useTransition };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}