{"ast":null,"code":"var $config = Symbol.for('FluidValue:config');\nexport { hasFluidValue, getFluidValue, getFluidConfig, setFluidConfig, addFluidObserver };\n/** Does the given value have a `FluidConfig` object? */\n\nvar hasFluidValue = function (arg) {\n  return !!getFluidConfig(arg);\n};\n\nfunction getFluidValue(arg) {\n  var config = getFluidConfig(arg);\n  return config ? config.get() : arg;\n}\n\nfunction getFluidConfig(arg) {\n  if (arg) return arg[$config];\n}\n/** Set the methods for observing the given object. */\n\n\nfunction setFluidConfig(target, config) {\n  Object.defineProperty(target, $config, {\n    value: config,\n    configurable: true\n  });\n}\n\nfunction addFluidObserver(target, observer) {\n  var config = getFluidConfig(target);\n\n  if (config) {\n    config.addChild(observer);\n    return function () {\n      return config.removeChild(observer);\n    };\n  }\n}\n/**\n * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.\n *\n * In order to support non-writable streams, this class doesn't expect a `set` method to exist.\n *\n * It can send *any* event to observers, not only change events.\n */\n\n\nvar FluidValue =\n/** @class */\nfunction () {\n  function FluidValue() {\n    setFluidConfig(this, this);\n  }\n\n  return FluidValue;\n}();\n\nexport { FluidValue };","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,IAAM,OAAO,GAAG,MAAM,CAAC,GAAP,CAAW,mBAAX,CAAhB;AAEA,SACE,aADF,EAEE,aAFF,EAGE,cAHF,EAIE,cAJF,EAKE,gBALF;AAQA;;AACA,IAAM,aAAa,GAAG,UAAC,GAAD,EAAS;AAAwB,SAAA,CAAC,CAAC,cAAc,CAAhB,GAAgB,CAAhB;AAAqB,CAA5E;;AAMA,SAAS,aAAT,CAAuB,GAAvB,EAA+B;AAC7B,MAAM,MAAM,GAAG,cAAc,CAAC,GAAD,CAA7B;AACA,SAAO,MAAM,GAAG,MAAM,CAAC,GAAP,EAAH,GAAkB,GAA/B;AACD;;AAQD,SAAS,cAAT,CAAwB,GAAxB,EAAgC;AAC9B,MAAI,GAAJ,EAAS,OAAO,GAAG,CAAC,OAAD,CAAV;AACV;AAED;;;AACA,SAAS,cAAT,CAAwB,MAAxB,EAAwC,MAAxC,EAA2D;AACzD,EAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB,EAA8B,OAA9B,EAAuC;AACrC,IAAA,KAAK,EAAE,MAD8B;AAErC,IAAA,YAAY,EAAE;AAFuB,GAAvC;AAID;;AAaD,SAAS,gBAAT,CAA0B,MAA1B,EAA0C,QAA1C,EAAiE;AAC/D,MAAM,MAAM,GAAG,cAAc,CAAC,MAAD,CAA7B;;AACA,MAAI,MAAJ,EAAY;AACV,IAAA,MAAM,CAAC,QAAP,CAAgB,QAAhB;AACA,WAAO,YAAA;AAAM,aAAA,MAAO,CAAC,WAAR,CAAA,QAAA,CAAA;AAA6B,KAA1C;AACD;AACF;AAyBD;;;;;;AAMG;;;AACH,IAAA,UAAA;AAAA;AAAA,YAAA;AAEE,WAAA,UAAA,GAAA;AACE,IAAA,cAAc,CAAC,IAAD,EAAO,IAAP,CAAd;AACD;;AAIH,SAAA,UAAA;AAAC,CARD,EAAA","sourceRoot":"","sourcesContent":["var $config = Symbol.for('FluidValue:config');\nexport { hasFluidValue, getFluidValue, getFluidConfig, setFluidConfig, addFluidObserver, };\n/** Does the given value have a `FluidConfig` object? */\nvar hasFluidValue = function (arg) { return !!getFluidConfig(arg); };\nfunction getFluidValue(arg) {\n    var config = getFluidConfig(arg);\n    return config ? config.get() : arg;\n}\nfunction getFluidConfig(arg) {\n    if (arg)\n        return arg[$config];\n}\n/** Set the methods for observing the given object. */\nfunction setFluidConfig(target, config) {\n    Object.defineProperty(target, $config, {\n        value: config,\n        configurable: true,\n    });\n}\nfunction addFluidObserver(target, observer) {\n    var config = getFluidConfig(target);\n    if (config) {\n        config.addChild(observer);\n        return function () { return config.removeChild(observer); };\n    }\n}\n/**\n * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.\n *\n * In order to support non-writable streams, this class doesn't expect a `set` method to exist.\n *\n * It can send *any* event to observers, not only change events.\n */\nvar FluidValue = /** @class */ (function () {\n    function FluidValue() {\n        setFluidConfig(this, this);\n    }\n    return FluidValue;\n}());\nexport { FluidValue };\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}