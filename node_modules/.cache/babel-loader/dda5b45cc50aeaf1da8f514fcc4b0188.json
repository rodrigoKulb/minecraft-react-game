{"ast":null,"code":"import * as G from './globals'; // The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\n\nvar requestAnimationFrame = function (fn) {\n  return (void 0, G.requestAnimationFrame)(fn);\n};\n/**\n * FrameLoop executes its animations in order of lowest priority first.\n * Animations are retained until idle.\n */\n\n\nvar FrameLoop =\n/** @class */\nfunction () {\n  function FrameLoop(raf) {\n    if (raf === void 0) {\n      raf = requestAnimationFrame;\n    }\n\n    var idle = true;\n    var writing = false; // The most recent framestamp\n\n    var lastTime = 0; // The active animations for the current frame, sorted by lowest priority first\n\n    var animations = []; // The priority of the currently advancing animation.\n    // To protect against a race condition whenever a frame is being processed,\n    // where the filtering of `animations` is corrupted with a shifting index,\n    // causing animations to potentially advance 2x faster than intended.\n\n    var priority = 0; // Animations starting on the next frame\n\n    var startQueue = new Set(); // Flushed after all animations are updated.\n    // Used to dispatch events to an \"onFrame\" prop, for example.\n\n    var frameQueue = new Set(); // Flushed at the very end of each frame.\n    // Used to avoid layout thrashing in @react-spring/web, for example.\n\n    var writeQueue = new Set(); // Add an animation to the frameloop\n\n    var start = function (animation) {\n      var index = animations.indexOf(animation);\n\n      if (index < 0) {\n        index = animations.findIndex(function (other) {\n          return other.priority > animation.priority;\n        });\n        animations.splice(~index ? index : animations.length, 0, animation);\n      }\n    };\n\n    var loop = function () {\n      if (idle) return;\n\n      try {\n        advance();\n        raf(loop);\n      } catch (e) {\n        console.error(e);\n      }\n    }; // Start the frameloop\n\n\n    var kickoff = function () {\n      if (idle) {\n        idle = false; // To minimize frame skips, the frameloop never stops.\n\n        if (lastTime == 0) {\n          lastTime = G.now();\n          raf(loop);\n        }\n      }\n    };\n\n    var timeoutQueue = [];\n\n    this.setTimeout = function (handler, ms) {\n      var time = G.now() + ms;\n\n      var cancel = function () {\n        var index = timeoutQueue.findIndex(function (t) {\n          return t.cancel == cancel;\n        });\n\n        if (index >= 0) {\n          timeoutQueue.splice(index, 1);\n        }\n      };\n\n      var index = findIndex(timeoutQueue, function (t) {\n        return t.time > time;\n      });\n      var timeout = {\n        time: time,\n        handler: handler,\n        cancel: cancel\n      };\n      timeoutQueue.splice(index, 0, timeout);\n      kickoff();\n      return timeout;\n    }; // Process the current frame.\n\n\n    var advance = this.advance = function () {\n      var time = G.now(); // Start animations that were added during last frame.\n\n      if (startQueue.size) {\n        startQueue.forEach(start);\n        startQueue.clear();\n      } // Flush the timeout queue.\n\n\n      if (timeoutQueue.length) {\n        G.batchedUpdates(function () {\n          var count = findIndex(timeoutQueue, function (t) {\n            return t.time > time;\n          });\n          timeoutQueue.splice(0, count).forEach(function (t) {\n            return t.handler();\n          });\n        });\n      }\n\n      if (time > lastTime) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        var dt_1 = Math.min(64, time - lastTime);\n        lastTime = time;\n        G.batchedUpdates(function () {\n          // Animations can be added while the frameloop is updating,\n          // but they need a higher priority to be started on this frame.\n          if (animations.length) {\n            G.willAdvance(animations);\n            animations = animations.filter(function (animation) {\n              priority = animation.priority; // Animations may go idle before the next frame.\n\n              if (!animation.idle) {\n                animation.advance(dt_1);\n              } // Remove idle animations.\n\n\n              return !animation.idle;\n            });\n            priority = 0;\n          }\n\n          if (frameQueue.size) {\n            frameQueue.forEach(function (onFrame) {\n              return onFrame(time);\n            });\n            frameQueue.clear();\n          }\n\n          if (writeQueue.size) {\n            writing = true;\n            writeQueue.forEach(function (write) {\n              return write(time);\n            });\n            writeQueue.clear();\n            writing = false;\n          }\n        });\n      }\n    };\n\n    this.start = function (animation) {\n      if (priority > animation.priority) {\n        startQueue.add(animation);\n      } else {\n        start(animation);\n        kickoff();\n      }\n    };\n\n    this.onFrame = function (cb) {\n      frameQueue.add(cb);\n      kickoff();\n    };\n\n    this.onWrite = function (cb) {\n      if (writing) cb(lastTime);else writeQueue.add(cb);\n    }; // Expose internals for testing.\n\n\n    if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {\n      var dispose_1 = function () {\n        idle = true;\n        startQueue.clear();\n        timeoutQueue.length = 0;\n      };\n\n      Object.defineProperties(this, {\n        _animations: {\n          get: function () {\n            return animations;\n          }\n        },\n        _dispose: {\n          get: function () {\n            return dispose_1;\n          }\n        }\n      });\n    }\n  }\n\n  return FrameLoop;\n}();\n\nexport { FrameLoop };\n/** Like `Array.prototype.findIndex` but returns `arr.length` instead of `-1` */\n\nfunction findIndex(arr, test) {\n  var index = arr.findIndex(test);\n  return index < 0 ? arr.length : index;\n}","map":{"version":3,"sources":["../../src/FrameLoop.ts"],"names":[],"mappings":"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","sourcesContent":["import { FrameRequestCallback } from './types'\nimport * as G from './globals'\n\ndeclare const console: any\ndeclare const process:\n  | { env: { [key: string]: string | undefined } }\n  | undefined\n\n// The global `requestAnimationFrame` must be dereferenced to avoid \"Illegal invocation\" errors\nconst requestAnimationFrame: RequestFrameFn = fn =>\n  (void 0, G.requestAnimationFrame)(fn)\n\nexport type RequestFrameFn = (cb: FrameRequestCallback) => number | void\n\nexport interface OpaqueAnimation {\n  idle: boolean\n  priority: number\n  advance(dt: number): void\n}\n\nexport interface Timeout {\n  time: number\n  handler: () => void\n  cancel: () => void\n}\n\n/**\n * FrameLoop executes its animations in order of lowest priority first.\n * Animations are retained until idle.\n */\nexport class FrameLoop {\n  /**\n   * Start a new animation, or reorder an active animation in\n   * the animations array in response to a priority change.\n   */\n  start: (animation: OpaqueAnimation) => void\n\n  /**\n   * Advance the animations to the current time.\n   */\n  advance: () => void\n\n  /**\n   * Invoke the given `handler` on the soonest frame after the given\n   * `ms` delay is completed. When the delay is `<= 0`, the handler is\n   * invoked immediately.\n   */\n  setTimeout: (handler: () => void, ms: number) => Timeout\n\n  /**\n   * Execute a function once after all animations have updated.\n   */\n  onFrame: (cb: FrameRequestCallback) => void\n\n  /**\n   * Execute a function once at the very end of the current frame.\n   *\n   * Only call this within an `onFrame` callback.\n   */\n  onWrite: (cb: FrameRequestCallback) => void\n\n  // Exposed for testing.\n  protected _animations!: OpaqueAnimation[]\n  protected _dispose!: () => void\n\n  constructor(raf = requestAnimationFrame) {\n    let idle = true\n    let writing = false\n\n    // The most recent framestamp\n    let lastTime = 0\n\n    // The active animations for the current frame, sorted by lowest priority first\n    let animations: OpaqueAnimation[] = []\n\n    // The priority of the currently advancing animation.\n    // To protect against a race condition whenever a frame is being processed,\n    // where the filtering of `animations` is corrupted with a shifting index,\n    // causing animations to potentially advance 2x faster than intended.\n    let priority = 0\n\n    // Animations starting on the next frame\n    const startQueue = new Set<OpaqueAnimation>()\n\n    // Flushed after all animations are updated.\n    // Used to dispatch events to an \"onFrame\" prop, for example.\n    const frameQueue = new Set<FrameRequestCallback>()\n\n    // Flushed at the very end of each frame.\n    // Used to avoid layout thrashing in @react-spring/web, for example.\n    const writeQueue = new Set<FrameRequestCallback>()\n\n    // Add an animation to the frameloop\n    const start = (animation: OpaqueAnimation) => {\n      let index = animations.indexOf(animation)\n      if (index < 0) {\n        index = animations.findIndex(\n          other => other.priority > animation.priority\n        )\n        animations.splice(~index ? index : animations.length, 0, animation)\n      }\n    }\n\n    const loop = () => {\n      if (idle) return\n      try {\n        advance()\n        raf(loop)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n\n    // Start the frameloop\n    const kickoff = () => {\n      if (idle) {\n        idle = false\n\n        // To minimize frame skips, the frameloop never stops.\n        if (lastTime == 0) {\n          lastTime = G.now()\n          raf(loop)\n        }\n      }\n    }\n\n    const timeoutQueue: Timeout[] = []\n\n    this.setTimeout = (handler, ms) => {\n      const time = G.now() + ms\n      const cancel = () => {\n        const index = timeoutQueue.findIndex(t => t.cancel == cancel)\n        if (index >= 0) {\n          timeoutQueue.splice(index, 1)\n        }\n      }\n\n      const index = findIndex(timeoutQueue, t => t.time > time)\n      const timeout = { time, handler, cancel }\n      timeoutQueue.splice(index, 0, timeout)\n\n      kickoff()\n      return timeout\n    }\n\n    // Process the current frame.\n    const advance = (this.advance = () => {\n      const time = G.now()\n\n      // Start animations that were added during last frame.\n      if (startQueue.size) {\n        startQueue.forEach(start)\n        startQueue.clear()\n      }\n\n      // Flush the timeout queue.\n      if (timeoutQueue.length) {\n        G.batchedUpdates(() => {\n          const count = findIndex(timeoutQueue, t => t.time > time)\n          timeoutQueue.splice(0, count).forEach(t => t.handler())\n        })\n      }\n\n      if (time > lastTime) {\n        // http://gafferongames.com/game-physics/fix-your-timestep/\n        const dt = Math.min(64, time - lastTime)\n        lastTime = time\n\n        G.batchedUpdates(() => {\n          // Animations can be added while the frameloop is updating,\n          // but they need a higher priority to be started on this frame.\n          if (animations.length) {\n            G.willAdvance(animations)\n            animations = animations.filter(animation => {\n              priority = animation.priority\n\n              // Animations may go idle before the next frame.\n              if (!animation.idle) {\n                animation.advance(dt)\n              }\n\n              // Remove idle animations.\n              return !animation.idle\n            })\n            priority = 0\n          }\n\n          if (frameQueue.size) {\n            frameQueue.forEach(onFrame => onFrame(time))\n            frameQueue.clear()\n          }\n\n          if (writeQueue.size) {\n            writing = true\n            writeQueue.forEach(write => write(time))\n            writeQueue.clear()\n            writing = false\n          }\n        })\n      }\n    })\n\n    this.start = animation => {\n      if (priority > animation.priority) {\n        startQueue.add(animation)\n      } else {\n        start(animation)\n        kickoff()\n      }\n    }\n\n    this.onFrame = cb => {\n      frameQueue.add(cb)\n      kickoff()\n    }\n\n    this.onWrite = cb => {\n      if (writing) cb(lastTime)\n      else writeQueue.add(cb)\n    }\n\n    // Expose internals for testing.\n    if (\n      typeof process !== 'undefined' &&\n      process.env.NODE_ENV !== 'production'\n    ) {\n      const dispose = () => {\n        idle = true\n        startQueue.clear()\n        timeoutQueue.length = 0\n      }\n      Object.defineProperties(this, {\n        _animations: { get: () => animations },\n        _dispose: { get: () => dispose },\n      })\n    }\n  }\n}\n\n/** Like `Array.prototype.findIndex` but returns `arr.length` instead of `-1` */\nfunction findIndex<T>(arr: T[], test: (value: T) => boolean) {\n  const index = arr.findIndex(test)\n  return index < 0 ? arr.length : index\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}