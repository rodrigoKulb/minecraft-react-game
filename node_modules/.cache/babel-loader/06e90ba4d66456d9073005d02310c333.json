{"ast":null,"code":"import * as G from './globals';\nexport var noop = function () {};\nexport var defineHidden = function (obj, key, value) {\n  return Object.defineProperty(obj, key, {\n    value: value,\n    writable: true,\n    configurable: true\n  });\n};\nexport var is = {\n  arr: Array.isArray,\n  obj: function (a) {\n    return !!a && a.constructor.name === 'Object';\n  },\n  fun: function (a) {\n    return typeof a === 'function';\n  },\n  str: function (a) {\n    return typeof a === 'string';\n  },\n  num: function (a) {\n    return typeof a === 'number';\n  },\n  und: function (a) {\n    return a === undefined;\n  }\n};\n/** Compare animatable values */\n\nexport function isEqual(a, b) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n} // Not all strings can be animated (eg: {display: \"none\"})\n\nexport var isAnimatedString = function (value) {\n  return is.str(value) && (value[0] == '#' || /\\d/.test(value) || !!(G.colorNames && G.colorNames[value]));\n};\n/** An unsafe object/array/set iterator that allows for better minification */\n\nexport var each = function (obj, cb, ctx) {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx);\n  } else {\n    Object.keys(obj).forEach(function (key) {\n      return cb.call(ctx, obj[key], key);\n    });\n  }\n};\nexport var toArray = function (a) {\n  return is.und(a) ? [] : is.arr(a) ? a : [a];\n};\nexport function flush(queue, iterator) {\n  if (queue.size) {\n    var items = Array.from(queue);\n    queue.clear();\n    each(items, iterator);\n  }\n}","map":{"version":3,"sources":["../../src/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Lookup, Arrify } from './types.util'\nimport * as G from './globals'\n\nexport const noop = () => {}\n\nexport const defineHidden = (obj: any, key: any, value: any) =>\n  Object.defineProperty(obj, key, { value, writable: true, configurable: true })\n\ninterface IsArray {\n  <T>(a: T): a is T & readonly any[]\n}\n\ntype PlainObject<T> = Exclude<T & Lookup, Function | readonly any[]>\n\nexport const is = {\n  arr: Array.isArray as IsArray,\n  obj: <T extends any>(a: T): a is PlainObject<T> =>\n    !!a && a.constructor.name === 'Object',\n  fun: (a: unknown): a is Function => typeof a === 'function',\n  str: (a: unknown): a is string => typeof a === 'string',\n  num: (a: unknown): a is number => typeof a === 'number',\n  und: (a: unknown): a is undefined => a === undefined,\n}\n\n/** Compare animatable values */\nexport function isEqual(a: any, b: any) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false\n    }\n    return true\n  }\n  return a === b\n}\n\n// Not all strings can be animated (eg: {display: \"none\"})\nexport const isAnimatedString = (value: unknown): value is string =>\n  is.str(value) &&\n  (value[0] == '#' ||\n    /\\d/.test(value) ||\n    !!(G.colorNames && G.colorNames[value]))\n\ntype Eachable<Value, Key> = {\n  forEach: (cb: (value: Value, key: Key) => void, ctx?: any) => void\n}\n\ntype InferKey<T extends object> = T extends Eachable<any, infer Key>\n  ? Key\n  : Extract<keyof T, string>\n\ntype InferValue<T extends object> = T extends\n  | Eachable<infer Value, any>\n  | { [key: string]: infer Value }\n  ? Value\n  : never\n\n/** An unsafe object/array/set iterator that allows for better minification */\nexport const each = <T extends object, This>(\n  obj: T & { forEach?: Function },\n  cb: (this: This, value: InferValue<T>, key: InferKey<T>) => void,\n  ctx?: This\n) => {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx)\n  } else {\n    Object.keys(obj).forEach(key =>\n      cb.call(ctx!, (obj as any)[key], key as any)\n    )\n  }\n}\n\nexport const toArray = <T>(a: T): Arrify<Exclude<T, void>> =>\n  is.und(a) ? [] : is.arr(a) ? (a as any) : [a]\n\n/** Copy the `queue`, then iterate it after the `queue` is cleared */\nexport function flush<P, T>(\n  queue: Map<P, T>,\n  iterator: (entry: [P, T]) => void\n): void\nexport function flush<T>(queue: Set<T>, iterator: (value: T) => void): void\nexport function flush(queue: any, iterator: any) {\n  if (queue.size) {\n    const items = Array.from(queue)\n    queue.clear()\n    each(items, iterator)\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}