{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.troika_worker_utils = {}));\n})(this, function (exports) {\n  'use strict';\n  /**\n   * Lightweight thenable implementation that is entirely self-contained within a single\n   * function with no external dependencies so it can be easily shipped across to a WorkerModule.\n   *\n   * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\n   * with other thenable implementations. https://github.com/promises-aplus/promises-spec\n   *\n   * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\n   * have the same constructor signature and does not expose a `catch` method or the static\n   * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\n   * instance off to consuming code that may expect a true Promise, you'll want to wrap it\n   * in a native-or-polyfilled Promise first.\n   *\n   * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\n   * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\n   * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\n   * implementation I've found. And also, exercises like this are challenging and fun.)\n   */\n\n  function BespokeThenable() {\n    var state = 0; // 0=pending, 1=fulfilled, -1=rejected\n\n    var queue = [];\n    var value;\n    var scheduled = 0;\n    var completeCalled = 0;\n\n    function then(onResolve, onReject) {\n      var nextThenable = BespokeThenable();\n\n      function handleNext() {\n        var cb = state > 0 ? onResolve : onReject;\n\n        if (isFn(cb)) {\n          try {\n            var result = cb(value);\n\n            if (result === nextThenable) {\n              recursiveError();\n            }\n\n            var resultThen = getThenableThen(result);\n\n            if (resultThen) {\n              resultThen.call(result, nextThenable.resolve, nextThenable.reject);\n            } else {\n              nextThenable.resolve(result);\n            }\n          } catch (err) {\n            nextThenable.reject(err);\n          }\n        } else {\n          nextThenable[state > 0 ? 'resolve' : 'reject'](value);\n        }\n      }\n\n      queue.push(handleNext);\n\n      if (state) {\n        scheduleQueueFlush();\n      }\n\n      return nextThenable;\n    }\n\n    var resolve = oneTime(function (val) {\n      if (!completeCalled) {\n        complete(1, val);\n      }\n    });\n    var reject = oneTime(function (reason) {\n      if (!completeCalled) {\n        complete(-1, reason);\n      }\n    });\n\n    function complete(st, val) {\n      completeCalled++;\n      var ignoreThrow = 0;\n\n      try {\n        if (val === thenableObj) {\n          recursiveError();\n        }\n\n        var valThen = st > 0 && getThenableThen(val);\n\n        if (valThen) {\n          valThen.call(val, oneTime(function (v) {\n            ignoreThrow++;\n            complete(1, v);\n          }), oneTime(function (v) {\n            ignoreThrow++;\n            complete(-1, v);\n          }));\n        } else {\n          state = st;\n          value = val;\n          scheduleQueueFlush();\n        }\n      } catch (e) {\n        if (!state && !ignoreThrow) {\n          complete(-1, e);\n        }\n      }\n    }\n\n    function scheduleQueueFlush() {\n      if (!scheduled) {\n        setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\n\n        scheduled = 1;\n      }\n    }\n\n    function flushQueue() {\n      var q = queue;\n      scheduled = 0;\n      queue = [];\n      q.forEach(callIt);\n    }\n\n    function callIt(fn) {\n      fn();\n    }\n\n    function getThenableThen(val) {\n      var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\n      return isFn(valThen) && valThen;\n    }\n\n    function oneTime(fn) {\n      var called = 0;\n      return function () {\n        var args = [],\n            len = arguments.length;\n\n        while (len--) args[len] = arguments[len];\n\n        if (!called++) {\n          fn.apply(this, args);\n        }\n      };\n    }\n\n    function recursiveError() {\n      throw new TypeError('Chaining cycle detected');\n    }\n\n    var isFn = function (v) {\n      return typeof v === 'function';\n    };\n\n    var thenableObj = {\n      then: then,\n      resolve: resolve,\n      reject: reject\n    };\n    return thenableObj;\n  }\n  /**\n   * Thenable implementation that uses a native Promise under the covers. This implementation\n   * is preferred if Promise is available, for better performance and dev tools integration.\n   * @constructor\n   */\n\n\n  function NativePromiseThenable() {\n    var resolve, reject;\n    var promise = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n    return {\n      then: promise.then.bind(promise),\n      resolve: resolve,\n      reject: reject\n    };\n  }\n  /**\n   * Promise.all() impl:\n   */\n\n\n  BespokeThenable.all = NativePromiseThenable.all = function (items) {\n    var resultCount = 0;\n    var results = [];\n    var out = DefaultThenable();\n\n    if (items.length === 0) {\n      out.resolve([]);\n    } else {\n      items.forEach(function (item, i) {\n        var itemThenable = DefaultThenable();\n        itemThenable.resolve(item);\n        itemThenable.then(function (res) {\n          resultCount++;\n          results[i] = res;\n\n          if (resultCount === items.length) {\n            out.resolve(results);\n          }\n        }, out.reject);\n      });\n    }\n\n    return out;\n  };\n  /**\n   * Choose the best Thenable implementation and export it as the default.\n   */\n\n\n  var DefaultThenable = typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable;\n  /**\n   * Main content for the worker that handles the loading and execution of\n   * modules within it.\n   */\n\n  function workerBootstrap() {\n    var modules = Object.create(null); // Handle messages for registering a module\n\n    function registerModule(ref, callback) {\n      var id = ref.id;\n      var name = ref.name;\n      var dependencies = ref.dependencies;\n      if (dependencies === void 0) dependencies = [];\n      var init = ref.init;\n      if (init === void 0) init = function () {};\n      var getTransferables = ref.getTransferables;\n      if (getTransferables === void 0) getTransferables = null; // Only register once\n\n      if (modules[id]) {\n        return;\n      }\n\n      try {\n        // If any dependencies are modules, ensure they're registered and grab their value\n        dependencies = dependencies.map(function (dep) {\n          if (dep && dep.isWorkerModule) {\n            registerModule(dep, function (depResult) {\n              if (depResult instanceof Error) {\n                throw depResult;\n              }\n            });\n            dep = modules[dep.id].value;\n          }\n\n          return dep;\n        }); // Rehydrate functions\n\n        init = rehydrate(\"<\" + name + \">.init\", init);\n\n        if (getTransferables) {\n          getTransferables = rehydrate(\"<\" + name + \">.getTransferables\", getTransferables);\n        } // Initialize the module and store its value\n\n\n        var value = null;\n\n        if (typeof init === 'function') {\n          value = init.apply(void 0, dependencies);\n        } else {\n          console.error('worker module init function failed to rehydrate');\n        }\n\n        modules[id] = {\n          id: id,\n          value: value,\n          getTransferables: getTransferables\n        };\n        callback(value);\n      } catch (err) {\n        if (!(err && err.noLog)) {\n          console.error(err);\n        }\n\n        callback(err);\n      }\n    } // Handle messages for calling a registered module's result function\n\n\n    function callModule(ref, callback) {\n      var ref$1;\n      var id = ref.id;\n      var args = ref.args;\n\n      if (!modules[id] || typeof modules[id].value !== 'function') {\n        callback(new Error(\"Worker module \" + id + \": not found or its 'init' did not return a function\"));\n      }\n\n      try {\n        var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n\n        if (result && typeof result.then === 'function') {\n          result.then(handleResult, function (rej) {\n            return callback(rej instanceof Error ? rej : new Error('' + rej));\n          });\n        } else {\n          handleResult(result);\n        }\n      } catch (err) {\n        callback(err);\n      }\n\n      function handleResult(result) {\n        try {\n          var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n\n          if (!tx || !Array.isArray(tx) || !tx.length) {\n            tx = undefined; //postMessage is very picky about not passing null or empty transferables\n          }\n\n          callback(result, tx);\n        } catch (err) {\n          console.error(err);\n          callback(err);\n        }\n      }\n    }\n\n    function rehydrate(name, str) {\n      var result = void 0;\n\n      self.troikaDefine = function (r) {\n        return result = r;\n      };\n\n      var url = URL.createObjectURL(new Blob([\"/** \" + name.replace(/\\*/g, '') + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\"], {\n        type: 'application/javascript'\n      }));\n\n      try {\n        importScripts(url);\n      } catch (err) {\n        console.error(err);\n      }\n\n      URL.revokeObjectURL(url);\n      delete self.troikaDefine;\n      return result;\n    } // Handler for all messages within the worker\n\n\n    self.addEventListener('message', function (e) {\n      var ref = e.data;\n      var messageId = ref.messageId;\n      var action = ref.action;\n      var data = ref.data;\n\n      try {\n        // Module registration\n        if (action === 'registerModule') {\n          registerModule(data, function (result) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: {\n                  isCallable: typeof result === 'function'\n                }\n              });\n            }\n          });\n        } // Invocation\n\n\n        if (action === 'callModule') {\n          callModule(data, function (result, transferables) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: result\n              }, transferables || undefined);\n            }\n          });\n        }\n      } catch (err) {\n        postMessage({\n          messageId: messageId,\n          success: false,\n          error: err.stack\n        });\n      }\n    });\n  }\n  /**\n   * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n   * thread, for when the execution environment doesn't support web workers or they\n   * are disallowed due to e.g. CSP security restrictions.\n   */\n\n\n  function defineMainThreadModule(options) {\n    var moduleFunc = function () {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      return moduleFunc._getInitResult().then(function (initResult) {\n        if (typeof initResult === 'function') {\n          return initResult.apply(void 0, args);\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function');\n        }\n      });\n    };\n\n    moduleFunc._getInitResult = function () {\n      // We can ignore getTransferables in main thread. TODO workerId?\n      var dependencies = options.dependencies;\n      var init = options.init; // Resolve dependencies\n\n      dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) {\n        return dep && dep._getInitResult ? dep._getInitResult() : dep;\n      }) : []; // Invoke init with the resolved dependencies\n\n      var initThenable = DefaultThenable.all(dependencies).then(function (deps) {\n        return init.apply(null, deps);\n      }); // Cache the resolved promise for subsequent calls\n\n      moduleFunc._getInitResult = function () {\n        return initThenable;\n      };\n\n      return initThenable;\n    };\n\n    return moduleFunc;\n  }\n\n  var supportsWorkers = function () {\n    var supported = false; // Only attempt worker initialization in browsers; elsewhere it would just be\n    // noise e.g. loading into a Node environment for SSR.\n\n    if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n      try {\n        // TODO additional checks for things like importScripts within the worker?\n        //  Would need to be an async check.\n        var worker = new Worker(URL.createObjectURL(new Blob([''], {\n          type: 'application/javascript'\n        })));\n        worker.terminate();\n        supported = true;\n      } catch (err) {\n        console.log(\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + err.message + \"]\");\n      }\n    } // Cached result\n\n\n    supportsWorkers = function () {\n      return supported;\n    };\n\n    return supported;\n  };\n\n  var _workerModuleId = 0;\n  var _messageId = 0;\n  var _allowInitAsString = false;\n  var workers = Object.create(null);\n  var openRequests = Object.create(null);\n  openRequests._count = 0;\n  /**\n   * Define a module of code that will be executed with a web worker. This provides a simple\n   * interface for moving chunks of logic off the main thread, and managing their dependencies\n   * among one another.\n   *\n   * @param {object} options\n   * @param {function} options.init - The main function that initializes the module. This will be run\n   *        within the worker, and will be passed the resolved dependencies as arguments. Its\n   *        return value becomes the module's content, which can then be used by other modules\n   *        that depend on it. This function can perform any logic using those dependencies, but\n   *        must not depend on anything from its parent closures.\n   * @param {array} [options.dependencies] - Provides any dependencies required by the init function:\n   *        - Primitives like strings, numbers, booleans\n   *        - Raw functions; these will be stringified and rehydrated within the worker so they\n   *          must not depend on anything from their parent closures\n   *        - Other worker modules; these will be resolved within the worker, and therefore modules\n   *          that provide functions can be called without having to cross the worker/main thread\n   *          boundary.\n   * @param {function} [options.getTransferables] - An optional function that will be run in the worker\n   *        just before posting the response value from a module call back to the main thread.\n   *        It will be passed that response value, and if it returns an array then that will be\n   *        used as the \"transferables\" parameter to `postMessage`. Use this if there are values\n   *        in the response that can/should be transfered rather than cloned.\n   * @param {string} [options.name] - A descriptive name for this module; this can be useful for\n   *        debugging but is not currently used for anything else.\n   * @param {string} [options.workerId] - By default all modules will run in the same dedicated worker,\n   *        but if you want to use multiple workers you can pass a `workerId` to indicate a specific\n   *        worker to spawn. Note that each worker is completely standalone and no data or state will\n   *        be shared between them. If a worker module is used as a dependency by worker modules\n   *        using different `workerId`s, then that dependency will be re-registered in each worker.\n   * @return {function(...[*]): {then}}\n   */\n\n  function defineWorkerModule(options) {\n    if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n      throw new Error('requires `options.init` function');\n    }\n\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n\n    if (!supportsWorkers()) {\n      return defineMainThreadModule(options);\n    }\n\n    if (workerId == null) {\n      workerId = '#default';\n    }\n\n    var id = \"workerModule\" + ++_workerModuleId;\n    var name = options.name || id;\n    var registrationThenable = null;\n    dependencies = dependencies && dependencies.map(function (dep) {\n      // Wrap raw functions as worker modules with no dependencies\n      if (typeof dep === 'function' && !dep.workerModuleData) {\n        _allowInitAsString = true;\n        dep = defineWorkerModule({\n          workerId: workerId,\n          name: \"<\" + name + \"> function dependency: \" + dep.name,\n          init: \"function(){return (\\n\" + stringifyFunction(dep) + \"\\n)}\"\n        });\n        _allowInitAsString = false;\n      } // Grab postable data for worker modules\n\n\n      if (dep && dep.workerModuleData) {\n        dep = dep.workerModuleData;\n      }\n\n      return dep;\n    });\n\n    function moduleFunc() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len]; // Register this module if needed\n\n\n      if (!registrationThenable) {\n        registrationThenable = callWorker(workerId, 'registerModule', moduleFunc.workerModuleData);\n      } // Invoke the module, returning a thenable\n\n\n      return registrationThenable.then(function (ref) {\n        var isCallable = ref.isCallable;\n\n        if (isCallable) {\n          return callWorker(workerId, 'callModule', {\n            id: id,\n            args: args\n          });\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function');\n        }\n      });\n    }\n\n    moduleFunc.workerModuleData = {\n      isWorkerModule: true,\n      id: id,\n      name: name,\n      dependencies: dependencies,\n      init: stringifyFunction(init),\n      getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    return moduleFunc;\n  }\n  /**\n   * Stringifies a function into a form that can be deserialized in the worker\n   * @param fn\n   */\n\n\n  function stringifyFunction(fn) {\n    var str = fn.toString(); // If it was defined in object method/property format, it needs to be modified\n\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n      str = 'function ' + str;\n    }\n\n    return str;\n  }\n\n  function getWorker(workerId) {\n    var worker = workers[workerId];\n\n    if (!worker) {\n      // Bootstrap the worker's content\n      var bootstrap = stringifyFunction(workerBootstrap); // Create the worker from the bootstrap function content\n\n      worker = workers[workerId] = new Worker(URL.createObjectURL(new Blob([\"/** Worker Module Bootstrap: \" + workerId.replace(/\\*/g, '') + \" **/\\n\\n;(\" + bootstrap + \")()\"], {\n        type: 'application/javascript'\n      }))); // Single handler for response messages from the worker\n\n      worker.onmessage = function (e) {\n        var response = e.data;\n        var msgId = response.messageId;\n        var callback = openRequests[msgId];\n\n        if (!callback) {\n          throw new Error('WorkerModule response with empty or unknown messageId');\n        }\n\n        delete openRequests[msgId];\n        openRequests.count--;\n        callback(response);\n      };\n    }\n\n    return worker;\n  } // Issue a call to the worker with a callback to handle the response\n\n\n  function callWorker(workerId, action, data) {\n    var thenable = DefaultThenable();\n    var messageId = ++_messageId;\n\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        thenable.resolve(response.result);\n      } else {\n        thenable.reject(new Error(\"Error in worker \" + action + \" call: \" + response.error));\n      }\n    };\n\n    openRequests._count++;\n\n    if (openRequests.count > 1000) {\n      //detect leaks\n      console.warn('Large number of open WorkerModule requests, some may not be returning');\n    }\n\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n    return thenable;\n  }\n  /**\n   * Just the {@link Thenable} function wrapped as a worker module. If another worker\n   * module needs Thenable as a dependency, it's better to pass this module rather than\n   * the raw function in its `dependencies` array so it only gets registered once.\n   */\n\n\n  var ThenableWorkerModule = defineWorkerModule({\n    name: 'Thenable',\n    dependencies: [DefaultThenable],\n    init: function (Thenable) {\n      return Thenable;\n    }\n  });\n  exports.Thenable = DefaultThenable;\n  exports.ThenableWorkerModule = ThenableWorkerModule;\n  exports.defineWorkerModule = defineWorkerModule;\n  exports.stringifyFunction = stringifyFunction;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/home/rodrigo/Dropbox/Projetos/rodrigoKulb/minecraft-react-game/node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js"],"names":["global","factory","exports","module","define","amd","self","troika_worker_utils","BespokeThenable","state","queue","value","scheduled","completeCalled","then","onResolve","onReject","nextThenable","handleNext","cb","isFn","result","recursiveError","resultThen","getThenableThen","call","resolve","reject","err","push","scheduleQueueFlush","oneTime","val","complete","reason","st","ignoreThrow","thenableObj","valThen","v","e","setTimeout","flushQueue","q","forEach","callIt","fn","called","args","len","arguments","length","apply","TypeError","NativePromiseThenable","promise","Promise","res","rej","bind","all","items","resultCount","results","out","DefaultThenable","item","i","itemThenable","workerBootstrap","modules","Object","create","registerModule","ref","callback","id","name","dependencies","init","getTransferables","map","dep","isWorkerModule","depResult","Error","rehydrate","console","error","noLog","callModule","ref$1","handleResult","tx","Array","isArray","undefined","str","troikaDefine","r","url","URL","createObjectURL","Blob","replace","type","importScripts","revokeObjectURL","addEventListener","data","messageId","action","postMessage","success","message","isCallable","transferables","stack","defineMainThreadModule","options","moduleFunc","_getInitResult","initResult","initThenable","deps","supportsWorkers","supported","window","document","worker","Worker","terminate","log","_workerModuleId","_messageId","_allowInitAsString","workers","openRequests","_count","defineWorkerModule","workerId","registrationThenable","workerModuleData","stringifyFunction","callWorker","toString","test","getWorker","bootstrap","onmessage","response","msgId","count","thenable","warn","ThenableWorkerModule","Thenable","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.troika_worker_utils = {}));\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Lightweight thenable implementation that is entirely self-contained within a single\n   * function with no external dependencies so it can be easily shipped across to a WorkerModule.\n   *\n   * This implementation conforms fully to the Promises/A+ spec so it can safely interoperate\n   * with other thenable implementations. https://github.com/promises-aplus/promises-spec\n   *\n   * *However*, it is _not_ a full implementation of ES2015 Promises, e.g. it does not\n   * have the same constructor signature and does not expose a `catch` method or the static\n   * `resolve`/`reject`/`all`/`race` initializer methods. If you need to hand a Thenable\n   * instance off to consuming code that may expect a true Promise, you'll want to wrap it\n   * in a native-or-polyfilled Promise first.\n   *\n   * (Why yet another Promises/A+ implementation? Great question. We needed a polyfill-like\n   * thing that was (a) wrapped in a single function for easy serialization across to a Worker,\n   * and (b) was as small as possible -- at ~900B minified (~500B gzipped) this is the smallest\n   * implementation I've found. And also, exercises like this are challenging and fun.)\n   */\n  function BespokeThenable() {\n    var state = 0; // 0=pending, 1=fulfilled, -1=rejected\n    var queue = [];\n    var value;\n    var scheduled = 0;\n    var completeCalled = 0;\n\n    function then(onResolve, onReject) {\n      var nextThenable = BespokeThenable();\n\n      function handleNext() {\n        var cb = state > 0 ? onResolve : onReject;\n        if (isFn(cb)) {\n          try {\n            var result = cb(value);\n            if (result === nextThenable) {\n              recursiveError();\n            }\n            var resultThen = getThenableThen(result);\n            if (resultThen) {\n              resultThen.call(result, nextThenable.resolve, nextThenable.reject);\n            } else {\n              nextThenable.resolve(result);\n            }\n          } catch (err) {\n            nextThenable.reject(err);\n          }\n        } else {\n          nextThenable[state > 0 ? 'resolve' : 'reject'](value);\n        }\n      }\n\n      queue.push(handleNext);\n      if (state) {\n        scheduleQueueFlush();\n      }\n      return nextThenable\n    }\n\n    var resolve = oneTime(function (val) {\n      if (!completeCalled) {\n        complete(1, val);\n      }\n    });\n\n    var reject = oneTime(function (reason) {\n      if (!completeCalled) {\n        complete(-1, reason);\n      }\n    });\n\n    function complete(st, val) {\n      completeCalled++;\n      var ignoreThrow = 0;\n      try {\n        if (val === thenableObj) {\n          recursiveError();\n        }\n        var valThen = st > 0 && getThenableThen(val);\n        if (valThen) {\n          valThen.call(val, oneTime(function (v) {\n            ignoreThrow++;\n            complete(1, v);\n          }), oneTime(function (v) {\n            ignoreThrow++;\n            complete(-1, v);\n          }));\n        } else {\n          state = st;\n          value = val;\n          scheduleQueueFlush();\n        }\n      } catch(e) {\n        if (!state && !ignoreThrow) {\n          complete(-1, e);\n        }\n      }\n    }\n\n    function scheduleQueueFlush() {\n      if (!scheduled) {\n        setTimeout(flushQueue, 0); //TODO setImmediate or postMessage approach if available?\n        scheduled = 1;\n      }\n    }\n\n    function flushQueue() {\n      var q = queue;\n      scheduled = 0;\n      queue = [];\n      q.forEach(callIt);\n    }\n\n    function callIt(fn) {\n      fn();\n    }\n\n    function getThenableThen(val) {\n      var valThen = val && (isFn(val) || typeof val === 'object') && val.then;\n      return isFn(valThen) && valThen\n    }\n\n    function oneTime(fn) {\n      var called = 0;\n      return function() {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        if (!called++) {\n          fn.apply(this, args);\n        }\n      }\n    }\n\n    function recursiveError() {\n      throw new TypeError('Chaining cycle detected')\n    }\n\n    var isFn = function (v) { return typeof v === 'function'; };\n\n    var thenableObj = {\n      then: then,\n      resolve: resolve,\n      reject: reject\n    };\n    return thenableObj\n  }\n\n\n  /**\n   * Thenable implementation that uses a native Promise under the covers. This implementation\n   * is preferred if Promise is available, for better performance and dev tools integration.\n   * @constructor\n   */\n  function NativePromiseThenable() {\n    var resolve, reject;\n    var promise = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n    return {\n      then: promise.then.bind(promise),\n      resolve: resolve,\n      reject: reject\n    }\n  }\n\n  /**\n   * Promise.all() impl:\n   */\n  BespokeThenable.all = NativePromiseThenable.all = function(items) {\n    var resultCount = 0;\n    var results = [];\n    var out = DefaultThenable();\n    if (items.length === 0) {\n      out.resolve([]);\n    } else {\n      items.forEach(function (item, i) {\n        var itemThenable = DefaultThenable();\n        itemThenable.resolve(item);\n        itemThenable.then(function (res) {\n          resultCount++;\n          results[i] = res;\n          if (resultCount === items.length) {\n            out.resolve(results);\n          }\n        }, out.reject);\n      });\n    }\n    return out\n  };\n\n\n  /**\n   * Choose the best Thenable implementation and export it as the default.\n   */\n  var DefaultThenable = typeof Promise === 'function' ? NativePromiseThenable : BespokeThenable;\n\n  /**\n   * Main content for the worker that handles the loading and execution of\n   * modules within it.\n   */\n  function workerBootstrap() {\n    var modules = Object.create(null);\n\n    // Handle messages for registering a module\n    function registerModule(ref, callback) {\n      var id = ref.id;\n      var name = ref.name;\n      var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n      var init = ref.init; if ( init === void 0 ) init = function(){};\n      var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n      // Only register once\n      if (modules[id]) { return }\n\n      try {\n        // If any dependencies are modules, ensure they're registered and grab their value\n        dependencies = dependencies.map(function (dep) {\n          if (dep && dep.isWorkerModule) {\n            registerModule(dep, function (depResult) {\n              if (depResult instanceof Error) { throw depResult }\n            });\n            dep = modules[dep.id].value;\n          }\n          return dep\n        });\n\n        // Rehydrate functions\n        init = rehydrate((\"<\" + name + \">.init\"), init);\n        if (getTransferables) {\n          getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n        }\n\n        // Initialize the module and store its value\n        var value = null;\n        if (typeof init === 'function') {\n          value = init.apply(void 0, dependencies);\n        } else {\n          console.error('worker module init function failed to rehydrate');\n        }\n        modules[id] = {\n          id: id,\n          value: value,\n          getTransferables: getTransferables\n        };\n        callback(value);\n      } catch(err) {\n        if (!(err && err.noLog)) {\n          console.error(err);\n        }\n        callback(err);\n      }\n    }\n\n    // Handle messages for calling a registered module's result function\n    function callModule(ref, callback) {\n      var ref$1;\n\n      var id = ref.id;\n      var args = ref.args;\n      if (!modules[id] || typeof modules[id].value !== 'function') {\n        callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n      }\n      try {\n        var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n        if (result && typeof result.then === 'function') {\n          result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n        } else {\n          handleResult(result);\n        }\n      } catch(err) {\n        callback(err);\n      }\n      function handleResult(result) {\n        try {\n          var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n          if (!tx || !Array.isArray(tx) || !tx.length) {\n            tx = undefined; //postMessage is very picky about not passing null or empty transferables\n          }\n          callback(result, tx);\n        } catch(err) {\n          console.error(err);\n          callback(err);\n        }\n      }\n    }\n\n    function rehydrate(name, str) {\n      var result = void 0;\n      self.troikaDefine = function (r) { return result = r; };\n      var url = URL.createObjectURL(\n        new Blob(\n          [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n          {type: 'application/javascript'}\n        )\n      );\n      try {\n        importScripts(url);\n      } catch(err) {\n        console.error(err);\n      }\n      URL.revokeObjectURL(url);\n      delete self.troikaDefine;\n      return result\n    }\n\n    // Handler for all messages within the worker\n    self.addEventListener('message', function (e) {\n      var ref = e.data;\n      var messageId = ref.messageId;\n      var action = ref.action;\n      var data = ref.data;\n      try {\n        // Module registration\n        if (action === 'registerModule') {\n          registerModule(data, function (result) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: {isCallable: typeof result === 'function'}\n              });\n            }\n          });\n        }\n        // Invocation\n        if (action === 'callModule') {\n          callModule(data, function (result, transferables) {\n            if (result instanceof Error) {\n              postMessage({\n                messageId: messageId,\n                success: false,\n                error: result.message\n              });\n            } else {\n              postMessage({\n                messageId: messageId,\n                success: true,\n                result: result\n              }, transferables || undefined);\n            }\n          });\n        }\n      } catch(err) {\n        postMessage({\n          messageId: messageId,\n          success: false,\n          error: err.stack\n        });\n      }\n    });\n  }\n\n  /**\n   * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n   * thread, for when the execution environment doesn't support web workers or they\n   * are disallowed due to e.g. CSP security restrictions.\n   */\n  function defineMainThreadModule(options) {\n    var moduleFunc = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return moduleFunc._getInitResult().then(function (initResult) {\n        if (typeof initResult === 'function') {\n          return initResult.apply(void 0, args)\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    };\n    moduleFunc._getInitResult = function() {\n      // We can ignore getTransferables in main thread. TODO workerId?\n      var dependencies = options.dependencies;\n      var init = options.init;\n\n      // Resolve dependencies\n      dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n      ) : [];\n\n      // Invoke init with the resolved dependencies\n      var initThenable = DefaultThenable.all(dependencies).then(function (deps) {\n        return init.apply(null, deps)\n      });\n\n      // Cache the resolved promise for subsequent calls\n      moduleFunc._getInitResult = function () { return initThenable; };\n\n      return initThenable\n    };\n    return moduleFunc\n  }\n\n  var supportsWorkers = function () {\n    var supported = false;\n\n    // Only attempt worker initialization in browsers; elsewhere it would just be\n    // noise e.g. loading into a Node environment for SSR.\n    if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n      try {\n        // TODO additional checks for things like importScripts within the worker?\n        //  Would need to be an async check.\n        var worker = new Worker(\n          URL.createObjectURL(\n            new Blob([''], { type: 'application/javascript' })\n          )\n        );\n        worker.terminate();\n        supported = true;\n      } catch (err) {\n        console.log((\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\"));\n      }\n    }\n\n    // Cached result\n    supportsWorkers = function () { return supported; };\n    return supported\n  };\n\n  var _workerModuleId = 0;\n  var _messageId = 0;\n  var _allowInitAsString = false;\n  var workers = Object.create(null);\n  var openRequests = Object.create(null);\n  openRequests._count = 0;\n\n\n  /**\n   * Define a module of code that will be executed with a web worker. This provides a simple\n   * interface for moving chunks of logic off the main thread, and managing their dependencies\n   * among one another.\n   *\n   * @param {object} options\n   * @param {function} options.init - The main function that initializes the module. This will be run\n   *        within the worker, and will be passed the resolved dependencies as arguments. Its\n   *        return value becomes the module's content, which can then be used by other modules\n   *        that depend on it. This function can perform any logic using those dependencies, but\n   *        must not depend on anything from its parent closures.\n   * @param {array} [options.dependencies] - Provides any dependencies required by the init function:\n   *        - Primitives like strings, numbers, booleans\n   *        - Raw functions; these will be stringified and rehydrated within the worker so they\n   *          must not depend on anything from their parent closures\n   *        - Other worker modules; these will be resolved within the worker, and therefore modules\n   *          that provide functions can be called without having to cross the worker/main thread\n   *          boundary.\n   * @param {function} [options.getTransferables] - An optional function that will be run in the worker\n   *        just before posting the response value from a module call back to the main thread.\n   *        It will be passed that response value, and if it returns an array then that will be\n   *        used as the \"transferables\" parameter to `postMessage`. Use this if there are values\n   *        in the response that can/should be transfered rather than cloned.\n   * @param {string} [options.name] - A descriptive name for this module; this can be useful for\n   *        debugging but is not currently used for anything else.\n   * @param {string} [options.workerId] - By default all modules will run in the same dedicated worker,\n   *        but if you want to use multiple workers you can pass a `workerId` to indicate a specific\n   *        worker to spawn. Note that each worker is completely standalone and no data or state will\n   *        be shared between them. If a worker module is used as a dependency by worker modules\n   *        using different `workerId`s, then that dependency will be re-registered in each worker.\n   * @return {function(...[*]): {then}}\n   */\n  function defineWorkerModule(options) {\n    if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n      throw new Error('requires `options.init` function')\n    }\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n\n    if (!supportsWorkers()) {\n      return defineMainThreadModule(options)\n    }\n\n    if (workerId == null) {\n      workerId = '#default';\n    }\n    var id = \"workerModule\" + (++_workerModuleId);\n    var name = options.name || id;\n    var registrationThenable = null;\n\n    dependencies = dependencies && dependencies.map(function (dep) {\n      // Wrap raw functions as worker modules with no dependencies\n      if (typeof dep === 'function' && !dep.workerModuleData) {\n        _allowInitAsString = true;\n        dep = defineWorkerModule({\n          workerId: workerId,\n          name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n          init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n        });\n        _allowInitAsString = false;\n      }\n      // Grab postable data for worker modules\n      if (dep && dep.workerModuleData) {\n        dep = dep.workerModuleData;\n      }\n      return dep\n    });\n\n    function moduleFunc() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      // Register this module if needed\n      if (!registrationThenable) {\n        registrationThenable = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      }\n\n      // Invoke the module, returning a thenable\n      return registrationThenable.then(function (ref) {\n        var isCallable = ref.isCallable;\n\n        if (isCallable) {\n          return callWorker(workerId,'callModule', {id: id, args: args})\n        } else {\n          throw new Error('Worker module function was called but `init` did not return a callable function')\n        }\n      })\n    }\n    moduleFunc.workerModuleData = {\n      isWorkerModule: true,\n      id: id,\n      name: name,\n      dependencies: dependencies,\n      init: stringifyFunction(init),\n      getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    return moduleFunc\n  }\n\n  /**\n   * Stringifies a function into a form that can be deserialized in the worker\n   * @param fn\n   */\n  function stringifyFunction(fn) {\n    var str = fn.toString();\n    // If it was defined in object method/property format, it needs to be modified\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n      str = 'function ' + str;\n    }\n    return str\n  }\n\n\n  function getWorker(workerId) {\n    var worker = workers[workerId];\n    if (!worker) {\n      // Bootstrap the worker's content\n      var bootstrap = stringifyFunction(workerBootstrap);\n\n      // Create the worker from the bootstrap function content\n      worker = workers[workerId] = new Worker(\n        URL.createObjectURL(\n          new Blob(\n            [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n            {type: 'application/javascript'}\n          )\n        )\n      );\n\n      // Single handler for response messages from the worker\n      worker.onmessage = function (e) {\n        var response = e.data;\n        var msgId = response.messageId;\n        var callback = openRequests[msgId];\n        if (!callback) {\n          throw new Error('WorkerModule response with empty or unknown messageId')\n        }\n        delete openRequests[msgId];\n        openRequests.count--;\n        callback(response);\n      };\n    }\n    return worker\n  }\n\n  // Issue a call to the worker with a callback to handle the response\n  function callWorker(workerId, action, data) {\n    var thenable = DefaultThenable();\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        thenable.resolve(response.result);\n      } else {\n        thenable.reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    openRequests._count++;\n    if (openRequests.count > 1000) { //detect leaks\n      console.warn('Large number of open WorkerModule requests, some may not be returning');\n    }\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n    return thenable\n  }\n\n  /**\n   * Just the {@link Thenable} function wrapped as a worker module. If another worker\n   * module needs Thenable as a dependency, it's better to pass this module rather than\n   * the raw function in its `dependencies` array so it only gets registered once.\n   */\n  var ThenableWorkerModule = defineWorkerModule({\n    name: 'Thenable',\n    dependencies: [DefaultThenable],\n    init: function(Thenable) {\n      return Thenable\n    }\n  });\n\n  exports.Thenable = DefaultThenable;\n  exports.ThenableWorkerModule = ThenableWorkerModule;\n  exports.defineWorkerModule = defineWorkerModule;\n  exports.stringifyFunction = stringifyFunction;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}