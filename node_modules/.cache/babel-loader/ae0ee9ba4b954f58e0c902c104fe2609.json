{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Geometry, Vector3 } from \"../../../build/three.module.js\";\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nvar SimplifyModifier = function () {};\n\n(function () {\n  var cb = new Vector3(),\n      ab = new Vector3();\n\n  function pushIfUnique(array, object) {\n    if (array.indexOf(object) === -1) array.push(object);\n  }\n\n  function removeFromArray(array, object) {\n    var k = array.indexOf(object);\n    if (k > -1) array.splice(k, 1);\n  }\n\n  function computeEdgeCollapseCost(u, v) {\n    // if we collapse edge uv by moving u to v then how\n    // much different will the model change, i.e. the \"error\".\n    var edgelength = v.position.distanceTo(u.position);\n    var curvature = 0;\n    var sideFaces = [];\n    var i,\n        il = u.faces.length,\n        face,\n        sideFace; // find the \"sides\" triangles that are on the edge uv\n\n    for (i = 0; i < il; i++) {\n      face = u.faces[i];\n\n      if (face.hasVertex(v)) {\n        sideFaces.push(face);\n      }\n    } // use the triangle facing most away from the sides\n    // to determine our curvature term\n\n\n    for (i = 0; i < il; i++) {\n      var minCurvature = 1;\n      face = u.faces[i];\n\n      for (var j = 0; j < sideFaces.length; j++) {\n        sideFace = sideFaces[j]; // use dot product of face normals.\n\n        var dotProd = face.normal.dot(sideFace.normal);\n        minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n      }\n\n      curvature = Math.max(curvature, minCurvature);\n    } // crude approach in attempt to preserve borders\n    // though it seems not to be totally correct\n\n\n    var borders = 0;\n\n    if (sideFaces.length < 2) {\n      // we add some arbitrary cost for borders,\n      // borders += 10;\n      curvature = 1;\n    }\n\n    var amt = edgelength * curvature + borders;\n    return amt;\n  }\n\n  function computeEdgeCostAtVertex(v) {\n    // compute the edge collapse cost for all edges that start\n    // from vertex v.  Since we are only interested in reducing\n    // the object by selecting the min cost edge at each step, we\n    // only cache the cost of the least cost edge at this vertex\n    // (in member variable collapse) as well as the value of the\n    // cost (in member variable collapseCost).\n    if (v.neighbors.length === 0) {\n      // collapse if no neighbors.\n      v.collapseNeighbor = null;\n      v.collapseCost = -0.01;\n      return;\n    }\n\n    v.collapseCost = 100000;\n    v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n    for (var i = 0; i < v.neighbors.length; i++) {\n      var collapseCost = computeEdgeCollapseCost(v, v.neighbors[i]);\n\n      if (!v.collapseNeighbor) {\n        v.collapseNeighbor = v.neighbors[i];\n        v.collapseCost = collapseCost;\n        v.minCost = collapseCost;\n        v.totalCost = 0;\n        v.costCount = 0;\n      }\n\n      v.costCount++;\n      v.totalCost += collapseCost;\n\n      if (collapseCost < v.minCost) {\n        v.collapseNeighbor = v.neighbors[i];\n        v.minCost = collapseCost;\n      }\n    } // we average the cost of collapsing at this vertex\n\n\n    v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n  }\n\n  function removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n\n    while (v.neighbors.length) {\n      var n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n\n    removeFromArray(vertices, v);\n  }\n\n  function removeFace(f, faces) {\n    removeFromArray(faces, f);\n    if (f.v1) removeFromArray(f.v1.faces, f);\n    if (f.v2) removeFromArray(f.v2.faces, f);\n    if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n    var vs = [f.v1, f.v2, f.v3];\n    var v1, v2;\n\n    for (var i = 0; i < 3; i++) {\n      v1 = vs[i];\n      v2 = vs[(i + 1) % 3];\n      if (!v1 || !v2) continue;\n      v1.removeIfNonNeighbor(v2);\n      v2.removeIfNonNeighbor(v1);\n    }\n  }\n\n  function collapse(vertices, faces, u, v) {\n    // u and v are pointers to vertices of an edge\n    // Collapse the edge uv by moving vertex u onto v\n    if (!v) {\n      // u is a vertex all by itself so just delete it..\n      removeVertex(u, vertices);\n      return;\n    }\n\n    var i;\n    var tmpVertices = [];\n\n    for (i = 0; i < u.neighbors.length; i++) {\n      tmpVertices.push(u.neighbors[i]);\n    } // delete triangles on edge uv:\n\n\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      if (u.faces[i].hasVertex(v)) {\n        removeFace(u.faces[i], faces);\n      }\n    } // update remaining triangles to have v instead of u\n\n\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      u.faces[i].replaceVertex(u, v);\n    }\n\n    removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n    for (i = 0; i < tmpVertices.length; i++) {\n      computeEdgeCostAtVertex(tmpVertices[i]);\n    }\n  }\n\n  function minimumCostEdge(vertices) {\n    // O(n * n) approach. TODO optimize this\n    var least = vertices[0];\n\n    for (var i = 0; i < vertices.length; i++) {\n      if (vertices[i].collapseCost < least.collapseCost) {\n        least = vertices[i];\n      }\n    }\n\n    return least;\n  } // we use a triangle class to represent structure of face slightly differently\n\n\n  function Triangle(v1, v2, v3, a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.normal = new Vector3();\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  Triangle.prototype.computeNormal = function () {\n    var vA = this.v1.position;\n    var vB = this.v2.position;\n    var vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  };\n\n  Triangle.prototype.hasVertex = function (v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  };\n\n  Triangle.prototype.replaceVertex = function (oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  };\n\n  function Vertex(v, id) {\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  Vertex.prototype.addUniqueNeighbor = function (vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  };\n\n  Vertex.prototype.removeIfNonNeighbor = function (n) {\n    var neighbors = this.neighbors;\n    var faces = this.faces;\n    var offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (var i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  };\n\n  SimplifyModifier.prototype.modify = function (geometry, count) {\n    if (geometry.isBufferGeometry) {\n      geometry = new Geometry().fromBufferGeometry(geometry);\n    }\n\n    geometry.mergeVertices();\n    var oldVertices = geometry.vertices; // Three Position\n\n    var oldFaces = geometry.faces; // Three Face\n    // conversion\n\n    var vertices = [];\n    var faces = [];\n    var i, il; //\n    // put data of original geometry in different data structures\n    //\n    // add vertices\n\n    for (i = 0, il = oldVertices.length; i < il; i++) {\n      var vertex = new Vertex(oldVertices[i], i);\n      vertices.push(vertex);\n    } // add faces\n\n\n    for (i = 0, il = oldFaces.length; i < il; i++) {\n      var face = oldFaces[i];\n      var a = face.a;\n      var b = face.b;\n      var c = face.c;\n      var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n      faces.push(triangle);\n    } // compute all edge collapse costs\n\n\n    for (i = 0, il = vertices.length; i < il; i++) {\n      computeEdgeCostAtVertex(vertices[i]);\n    }\n\n    var nextVertex;\n    var z = count;\n\n    while (z--) {\n      nextVertex = minimumCostEdge(vertices);\n\n      if (!nextVertex) {\n        console.log('THREE.SimplifyModifier: No next vertex');\n        break;\n      }\n\n      collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n    } //\n\n\n    var simplifiedGeometry = new BufferGeometry();\n    var position = [];\n    var index = []; //\n\n    for (i = 0; i < vertices.length; i++) {\n      var vertex = vertices[i].position;\n      position.push(vertex.x, vertex.y, vertex.z);\n    } //\n\n\n    for (i = 0; i < faces.length; i++) {\n      var face = faces[i];\n      var a = vertices.indexOf(face.v1);\n      var b = vertices.indexOf(face.v2);\n      var c = vertices.indexOf(face.v3);\n      index.push(a, b, c);\n    } //\n\n\n    simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    simplifiedGeometry.setIndex(index);\n    return simplifiedGeometry;\n  };\n})();\n\nexport { SimplifyModifier };","map":{"version":3,"sources":["/home/rodrigo/Dropbox/Projetos/rodrigoKulb/minecraft-react/node_modules/three/examples/jsm/modifiers/SimplifyModifier.js"],"names":["BufferGeometry","Float32BufferAttribute","Geometry","Vector3","SimplifyModifier","cb","ab","pushIfUnique","array","object","indexOf","push","removeFromArray","k","splice","computeEdgeCollapseCost","u","v","edgelength","position","distanceTo","curvature","sideFaces","i","il","faces","length","face","sideFace","hasVertex","minCurvature","j","dotProd","normal","dot","Math","min","max","borders","amt","computeEdgeCostAtVertex","neighbors","collapseNeighbor","collapseCost","minCost","totalCost","costCount","removeVertex","vertices","console","assert","n","pop","removeFace","f","v1","v2","v3","vs","removeIfNonNeighbor","collapse","tmpVertices","replaceVertex","minimumCostEdge","least","Triangle","a","b","c","computeNormal","addUniqueNeighbor","prototype","vA","vB","vC","subVectors","cross","normalize","copy","oldv","newv","Vertex","id","vertex","offset","modify","geometry","count","isBufferGeometry","fromBufferGeometry","mergeVertices","oldVertices","oldFaces","triangle","nextVertex","z","log","simplifiedGeometry","index","x","y","setAttribute","setIndex"],"mappings":"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","sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tGeometry,\n\tVector3\n} from \"../../../build/three.module.js\";\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nvar SimplifyModifier = function () {};\n\n( function () {\n\n\tvar cb = new Vector3(), ab = new Vector3();\n\n\tfunction pushIfUnique( array, object ) {\n\n\t\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n\t}\n\n\tfunction removeFromArray( array, object ) {\n\n\t\tvar k = array.indexOf( object );\n\t\tif ( k > - 1 ) array.splice( k, 1 );\n\n\t}\n\n\tfunction computeEdgeCollapseCost( u, v ) {\n\n\t\t// if we collapse edge uv by moving u to v then how\n\t\t// much different will the model change, i.e. the \"error\".\n\n\t\tvar edgelength = v.position.distanceTo( u.position );\n\t\tvar curvature = 0;\n\n\t\tvar sideFaces = [];\n\t\tvar i, il = u.faces.length, face, sideFace;\n\n\t\t// find the \"sides\" triangles that are on the edge uv\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = u.faces[ i ];\n\n\t\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\t\tsideFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use the triangle facing most away from the sides\n\t\t// to determine our curvature term\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tvar minCurvature = 1;\n\t\t\tface = u.faces[ i ];\n\n\t\t\tfor ( var j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\t\tsideFace = sideFaces[ j ];\n\t\t\t\t// use dot product of face normals.\n\t\t\t\tvar dotProd = face.normal.dot( sideFace.normal );\n\t\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t\t}\n\n\t\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t\t}\n\n\t\t// crude approach in attempt to preserve borders\n\t\t// though it seems not to be totally correct\n\t\tvar borders = 0;\n\t\tif ( sideFaces.length < 2 ) {\n\n\t\t\t// we add some arbitrary cost for borders,\n\t\t\t// borders += 10;\n\t\t\tcurvature = 1;\n\n\t\t}\n\n\t\tvar amt = edgelength * curvature + borders;\n\n\t\treturn amt;\n\n\t}\n\n\tfunction computeEdgeCostAtVertex( v ) {\n\n\t\t// compute the edge collapse cost for all edges that start\n\t\t// from vertex v.  Since we are only interested in reducing\n\t\t// the object by selecting the min cost edge at each step, we\n\t\t// only cache the cost of the least cost edge at this vertex\n\t\t// (in member variable collapse) as well as the value of the\n\t\t// cost (in member variable collapseCost).\n\n\t\tif ( v.neighbors.length === 0 ) {\n\n\t\t\t// collapse if no neighbors.\n\t\t\tv.collapseNeighbor = null;\n\t\t\tv.collapseCost = - 0.01;\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tv.collapseCost = 100000;\n\t\tv.collapseNeighbor = null;\n\n\t\t// search all neighboring edges for \"least cost\" edge\n\t\tfor ( var i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\t\tvar collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\tv.collapseCost = collapseCost;\n\t\t\t\tv.minCost = collapseCost;\n\t\t\t\tv.totalCost = 0;\n\t\t\t\tv.costCount = 0;\n\n\t\t\t}\n\n\t\t\tv.costCount ++;\n\t\t\tv.totalCost += collapseCost;\n\n\t\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\tv.minCost = collapseCost;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// we average the cost of collapsing at this vertex\n\t\tv.collapseCost = v.totalCost / v.costCount;\n\t\t// v.collapseCost = v.minCost;\n\n\t}\n\n\tfunction removeVertex( v, vertices ) {\n\n\t\tconsole.assert( v.faces.length === 0 );\n\n\t\twhile ( v.neighbors.length ) {\n\n\t\t\tvar n = v.neighbors.pop();\n\t\t\tremoveFromArray( n.neighbors, v );\n\n\t\t}\n\n\t\tremoveFromArray( vertices, v );\n\n\t}\n\n\tfunction removeFace( f, faces ) {\n\n\t\tremoveFromArray( faces, f );\n\n\t\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\t\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\t\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t\t// TODO optimize this!\n\t\tvar vs = [ f.v1, f.v2, f.v3 ];\n\t\tvar v1, v2;\n\n\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\tv1 = vs[ i ];\n\t\t\tv2 = vs[ ( i + 1 ) % 3 ];\n\n\t\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\t\tv1.removeIfNonNeighbor( v2 );\n\t\t\tv2.removeIfNonNeighbor( v1 );\n\n\t\t}\n\n\t}\n\n\tfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t\t// Collapse the edge uv by moving vertex u onto v\n\n\t\tif ( ! v ) {\n\n\t\t\t// u is a vertex all by itself so just delete it..\n\t\t\tremoveVertex( u, vertices );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar i;\n\t\tvar tmpVertices = [];\n\n\t\tfor ( i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t\t}\n\n\n\t\t// delete triangles on edge uv:\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\tif ( u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update remaining triangles to have v instead of u\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t\t}\n\n\n\t\tremoveVertex( u, vertices );\n\n\t\t// recompute the edge collapse costs in neighborhood\n\t\tfor ( i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t\t}\n\n\t}\n\n\n\n\tfunction minimumCostEdge( vertices ) {\n\n\t\t// O(n * n) approach. TODO optimize this\n\n\t\tvar least = vertices[ 0 ];\n\n\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\t\tleast = vertices[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn least;\n\n\t}\n\n\t// we use a triangle class to represent structure of face slightly differently\n\n\tfunction Triangle( v1, v2, v3, a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t\tthis.normal = new Vector3();\n\n\t\tthis.computeNormal();\n\n\t\tv1.faces.push( this );\n\t\tv1.addUniqueNeighbor( v2 );\n\t\tv1.addUniqueNeighbor( v3 );\n\n\t\tv2.faces.push( this );\n\t\tv2.addUniqueNeighbor( v1 );\n\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\tv3.faces.push( this );\n\t\tv3.addUniqueNeighbor( v1 );\n\t\tv3.addUniqueNeighbor( v2 );\n\n\t}\n\n\tTriangle.prototype.computeNormal = function () {\n\n\t\tvar vA = this.v1.position;\n\t\tvar vB = this.v2.position;\n\t\tvar vC = this.v3.position;\n\n\t\tcb.subVectors( vC, vB );\n\t\tab.subVectors( vA, vB );\n\t\tcb.cross( ab ).normalize();\n\n\t\tthis.normal.copy( cb );\n\n\t};\n\n\tTriangle.prototype.hasVertex = function ( v ) {\n\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t};\n\n\tTriangle.prototype.replaceVertex = function ( oldv, newv ) {\n\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\tremoveFromArray( oldv.faces, this );\n\t\tnewv.faces.push( this );\n\n\n\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\tthis.computeNormal();\n\n\t};\n\n\tfunction Vertex( v, id ) {\n\n\t\tthis.position = v;\n\n\t\tthis.id = id; // old index id\n\n\t\tthis.faces = []; // faces vertex is connected\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t}\n\n\tVertex.prototype.addUniqueNeighbor = function ( vertex ) {\n\n\t\tpushIfUnique( this.neighbors, vertex );\n\n\t};\n\n\tVertex.prototype.removeIfNonNeighbor = function ( n ) {\n\n\t\tvar neighbors = this.neighbors;\n\t\tvar faces = this.faces;\n\n\t\tvar offset = neighbors.indexOf( n );\n\t\tif ( offset === - 1 ) return;\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t}\n\n\t\tneighbors.splice( offset, 1 );\n\n\t};\n\n\tSimplifyModifier.prototype.modify = function ( geometry, count ) {\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new Geometry().fromBufferGeometry( geometry );\n\n\t\t}\n\n\t\tgeometry.mergeVertices();\n\n\t\tvar oldVertices = geometry.vertices; // Three Position\n\t\tvar oldFaces = geometry.faces; // Three Face\n\n\t\t// conversion\n\t\tvar vertices = [];\n\t\tvar faces = [];\n\n\t\tvar i, il;\n\n\t\t//\n\t\t// put data of original geometry in different data structures\n\t\t//\n\n\t\t// add vertices\n\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = new Vertex( oldVertices[ i ], i );\n\t\t\tvertices.push( vertex );\n\n\t\t}\n\n\t\t// add faces\n\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\tvar face = oldFaces[ i ];\n\n\t\t\tvar a = face.a;\n\t\t\tvar b = face.b;\n\t\t\tvar c = face.c;\n\n\t\t\tvar triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\tfaces.push( triangle );\n\n\t\t}\n\n\t\t// compute all edge collapse costs\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t}\n\n\t\tvar nextVertex;\n\n\t\tvar z = count;\n\n\t\twhile ( z -- ) {\n\n\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t}\n\n\t\t//\n\n\t\tvar simplifiedGeometry = new BufferGeometry();\n\t\tvar position = [];\n\t\tvar index = [];\n\n\t\t//\n\n\t\tfor ( i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tvar vertex = vertices[ i ].position;\n\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar a = vertices.indexOf( face.v1 );\n\t\t\tvar b = vertices.indexOf( face.v2 );\n\t\t\tvar c = vertices.indexOf( face.v3 );\n\n\t\t\tindex.push( a, b, c );\n\n\t\t}\n\n\t\t//\n\n\t\tsimplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tsimplifiedGeometry.setIndex( index );\n\n\t\treturn simplifiedGeometry;\n\n\t};\n\n} )();\n\nexport { SimplifyModifier };\n"]},"metadata":{},"sourceType":"module"}