{"ast":null,"code":"import { defineHidden, is, createInterpolator, each, getFluidConfig, isAnimatedString, useForceUpdate } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop } from '@react-spring/shared/globals';\nimport { forwardRef, useRef, createElement } from 'react';\nimport { useLayoutEffect } from 'react-layout-effect';\nconst $node = Symbol.for('Animated:node');\n\nconst isAnimated = value => !!value && value[$node] === value;\n/** Get the owner's `Animated` node. */\n\n\nconst getAnimated = owner => owner && owner[$node];\n/** Set the owner's `Animated` node. */\n\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\n\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\n\nclass Animated {\n  /** The cache of animated values */\n  constructor() {\n    this.payload = void 0; // This makes \"isAnimated\" return true.\n\n    setAnimated(this, this);\n  }\n  /** Get the current value. Pass `true` for only animated values. */\n\n  /** Get every `AnimatedValue` used by this node. */\n\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n/** An animated number or a native attribute value */\n\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.elapsedTime = void 0;\n    this.lastPosition = void 0;\n    this.lastVelocity = void 0;\n    this.v0 = void 0;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n  /**\n   * Set the current value and optionally round it.\n   *\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\n   * It works with fractions and whole numbers. The best use case is (probably)\n   * rounding to the pixel grid with a step of:\n   *\n   *      1 / window.devicePixelRatio\n   */\n\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._value = void 0;\n    this._string = null;\n    this._toString = void 0;\n    this._toString = createInterpolator({\n      output: [from, to]\n    });\n  }\n\n  static create(from, to = from) {\n    if (is.str(from) && is.str(to)) {\n      return new AnimatedString(from, to);\n    }\n\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (!is.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  current: null\n};\n/** An object containing `Animated` nodes */\n\nclass AnimatedObject extends Animated {\n  constructor(source = null) {\n    super();\n    this.source = void 0;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else {\n        const config = getFluidConfig(source);\n\n        if (config) {\n          values[key] = config.get();\n        } else if (!animated) {\n          values[key] = source;\n        }\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    const config = getFluidConfig(source);\n\n    if (config && TreeContext.current) {\n      TreeContext.current.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n/** An array of animated nodes */\n\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    this.source = void 0;\n    super.setValue(this._makeAnimated(from, to));\n  }\n\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n\n  _makeAnimated(from, to = from) {\n    return from ? from.map((from, i) => (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  /** Equals true when an update is scheduled for \"end of frame\" */\n  constructor(update) {\n    super(null);\n    this.update = update;\n    this.dirty = false;\n  }\n\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      TreeContext.current = context;\n\n      if (props.style) {\n        const {\n          createAnimatedStyle\n        } = context.host;\n        props = _extends(_extends({}, props), {}, {\n          style: createAnimatedStyle(props.style)\n        });\n      }\n    }\n\n    super.setValue(props);\n    TreeContext.current = null;\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (!this.dirty && type === 'change') {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n\n}\n\nconst withAnimated = (Component, host) => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies,\n    host\n  });\n  useLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return /*#__PURE__*/createElement(Component, _extends({}, host.getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n} // For storing the animated version on the original component\n\n\nconst cacheKey = Symbol.for('AnimatedComponent');\n\nconst createHost = (components, {\n  applyAnimatedValues = () => false,\n  createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (is.str(Component)) {\n      Component = withAnimated(Component, hostConfig);\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = \"Animated(\" + displayName + \")\";\n    return Component;\n  };\n\n  each(components, (Component, key) => {\n    if (!is.str(key)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedValue, createHost, getAnimated, getPayload, isAnimated, setAnimated };","map":{"version":3,"sources":["src/Animated.ts","src/AnimatedValue.ts","src/AnimatedString.ts","src/context.ts","src/AnimatedObject.ts","src/AnimatedArray.ts","src/AnimatedProps.ts","src/withAnimated.tsx","src/createHost.ts"],"names":["$node","Symbol","isAnimated","value","getAnimated","owner","setAnimated","defineHidden","getPayload","payload","constructor","done","elapsedTime","lastPosition","lastVelocity","v0","_value","is","getValue","setValue","Math","reset","_string","_toString","createInterpolator","output","to","TypeError","TreeContext","current","source","values","each","config","getFluidConfig","node","_makePayload","Array","_addToPayload","newValue","_makeAnimated","from","isAnimatedString","dirty","update","props","createAnimatedStyle","context","style","onParentChange","type","G","withAnimated","forwardRef","instanceRef","useRef","hasInstance","Component","forceUpdate","useForceUpdate","instance","didUpdate","host","dependencies","useLayoutEffect","dep","updateRef","ref","cacheKey","createHost","applyAnimatedValues","getComponentProps","hostConfig","animated","displayName","getDisplayName","key","arg"],"mappings":"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","sourcesContent":["import { defineHidden, is, createInterpolator, each, getFluidConfig, isAnimatedString, useForceUpdate } from '@react-spring/shared';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport { frameLoop } from '@react-spring/shared/globals';\nimport { forwardRef, useRef, createElement } from 'react';\nimport { useLayoutEffect } from 'react-layout-effect';\n\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\n/** Get the owner's `Animated` node. */\n\nconst getAnimated = owner => owner && owner[$node];\n/** Set the owner's `Animated` node. */\n\nconst setAnimated = (owner, node) => defineHidden(owner, $node, node);\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\n\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  /** The cache of animated values */\n  constructor() {\n    this.payload = void 0;\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this);\n  }\n  /** Get the current value. Pass `true` for only animated values. */\n\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\n/** An animated number or a native attribute value */\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.elapsedTime = void 0;\n    this.lastPosition = void 0;\n    this.lastVelocity = void 0;\n    this.v0 = void 0;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(from, _to) {\n    return new AnimatedValue(from);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n  /**\n   * Set the current value and optionally round it.\n   *\n   * The `step` argument does nothing whenever it equals `undefined` or `0`.\n   * It works with fractions and whole numbers. The best use case is (probably)\n   * rounding to the pixel grid with a step of:\n   *\n   *      1 / window.devicePixelRatio\n   */\n\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(from, to) {\n    super(0);\n    this._value = void 0;\n    this._string = null;\n    this._toString = void 0;\n    this._toString = createInterpolator({\n      output: [from, to]\n    });\n  }\n\n  static create(from, to = from) {\n    if (is.str(from) && is.str(to)) {\n      return new AnimatedString(from, to);\n    }\n\n    throw TypeError('Expected \"from\" and \"to\" to be strings');\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (!is.num(value)) {\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  current: null\n};\n\n/** An object containing `Animated` nodes */\nclass AnimatedObject extends Animated {\n  constructor(source = null) {\n    super();\n    this.source = void 0;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    if (!this.source) return null;\n    const values = {};\n    each(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else {\n        const config = getFluidConfig(source);\n\n        if (config) {\n          values[key] = config.get();\n        } else if (!animated) {\n          values[key] = source;\n        }\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      each(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    const config = getFluidConfig(source);\n\n    if (config && TreeContext.current) {\n      TreeContext.current.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}\n\n/** An array of animated nodes */\nclass AnimatedArray extends AnimatedObject {\n  constructor(from, to) {\n    super(null);\n    this.source = void 0;\n    super.setValue(this._makeAnimated(from, to));\n  }\n\n  static create(from, to) {\n    return new AnimatedArray(from, to);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(newValue) {\n    const payload = this.getPayload(); // Reuse the payload when lengths are equal.\n\n    if (newValue && newValue.length == payload.length) {\n      each(payload, (node, i) => node.setValue(newValue[i]));\n    } else {\n      // Remake the payload when length changes.\n      this.source = this._makeAnimated(newValue);\n      this.payload = this._makePayload(this.source);\n    }\n  }\n  /** Convert the `from` and `to` values to an array of `Animated` nodes */\n\n\n  _makeAnimated(from, to = from) {\n    return from ? from.map((from, i) => (isAnimatedString(from) ? AnimatedString : AnimatedValue).create(from, to[i])) : [];\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObject {\n  /** Equals true when an update is scheduled for \"end of frame\" */\n  constructor(update) {\n    super(null);\n    this.update = update;\n    this.dirty = false;\n  }\n\n  setValue(props, context) {\n    if (!props) return; // The constructor passes null.\n\n    if (context) {\n      TreeContext.current = context;\n\n      if (props.style) {\n        const {\n          createAnimatedStyle\n        } = context.host;\n        props = _extends(_extends({}, props), {}, {\n          style: createAnimatedStyle(props.style)\n        });\n      }\n    }\n\n    super.setValue(props);\n    TreeContext.current = null;\n  }\n  /** @internal */\n\n\n  onParentChange({\n    type\n  }) {\n    if (!this.dirty && type === 'change') {\n      this.dirty = true;\n      frameLoop.onFrame(() => {\n        this.dirty = false;\n        this.update();\n      });\n    }\n  }\n\n}\n\nconst withAnimated = (Component, host) => forwardRef((rawProps, ref) => {\n  const instanceRef = useRef(null);\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  const forceUpdate = useForceUpdate();\n  const props = new AnimatedProps(() => {\n    const instance = instanceRef.current;\n\n    if (hasInstance && !instance) {\n      return; // The wrapped component forgot to forward its ref.\n    }\n\n    const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false; // Re-render the component when native updates fail.\n\n    if (didUpdate === false) {\n      forceUpdate();\n    }\n  });\n  const dependencies = new Set();\n  props.setValue(rawProps, {\n    dependencies,\n    host\n  });\n  useLayoutEffect(() => {\n    each(dependencies, dep => dep.addChild(props));\n    return () => each(dependencies, dep => dep.removeChild(props));\n  });\n  return /*#__PURE__*/createElement(Component, _extends({}, host.getComponentProps(props.getValue()), {\n    ref: hasInstance && (value => {\n      instanceRef.current = updateRef(ref, value);\n    })\n  }));\n});\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst createHost = (components, {\n  applyAnimatedValues = () => false,\n  createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (is.str(Component)) {\n      Component = withAnimated(Component, hostConfig);\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = \"Animated(\" + displayName + \")\";\n    return Component;\n  };\n\n  each(components, (Component, key) => {\n    if (!is.str(key)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedProps, AnimatedString, AnimatedValue, createHost, getAnimated, getPayload, isAnimated, setAnimated };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}