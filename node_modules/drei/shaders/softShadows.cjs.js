'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var THREE = require('three');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);

var pcss = function pcss(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$frustrum = _ref.frustrum,
      frustrum = _ref$frustrum === void 0 ? 3.75 : _ref$frustrum,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 0.005 : _ref$size,
      _ref$near = _ref.near,
      near = _ref$near === void 0 ? 9.5 : _ref$near,
      _ref$samples = _ref.samples,
      samples = _ref$samples === void 0 ? 17 : _ref$samples,
      _ref$rings = _ref.rings,
      rings = _ref$rings === void 0 ? 11 : _ref$rings;

  return "#define LIGHT_WORLD_SIZE " + size + "\n#define LIGHT_FRUSTUM_WIDTH " + frustrum + "\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE " + near + "\n\n#define NUM_SAMPLES " + samples + "\n#define NUM_RINGS " + rings + "\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n#define PCF_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\n\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n\tfloat angle = rand(randomSeed) * PI2;\n\tfloat radius = INV_NUM_SAMPLES;\n\tfloat radiusStep = radius;\n\tfor (int i = 0; i < NUM_SAMPLES; i++) {\n\t\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n\treturn (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n\tfloat blockerDepthSum = 0.0;\n\tint numBlockers = 0;\n\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\tif (shadowMapDepth < zReceiver) {\n\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\tnumBlockers++;\n\t\t}\n\t}\n\tif (numBlockers == 0) return -1.0;\n\treturn blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n\tvec2 uv = coords.xy;\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\tinitPoissonSamples(uv);\n\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\tif (avgBlockerDepth == -1.0) return 1.0;\n\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}";
};

var deployed = false;
var softShadows = function softShadows(props) {
  // Avoid adding the effect twice, which may happen in HMR scenarios
  if (!deployed) {
    deployed = true;
    var shader = THREE.ShaderChunk.shadowmap_pars_fragment;
    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\n' + pcss(_extends__default['default']({}, props)));
    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )');
    THREE.ShaderChunk.shadowmap_pars_fragment = shader;
  }
};

exports.softShadows = softShadows;
