'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var React = require('react');
var reactThreeFiber = require('react-three-fiber');
var r3fTroika = require('r3f-troika');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var _objectWithoutPropertiesLoose__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutPropertiesLoose);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var Text = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$anchorX = _ref.anchorX,
      anchorX = _ref$anchorX === void 0 ? 'center' : _ref$anchorX,
      _ref$anchorY = _ref.anchorY,
      anchorY = _ref$anchorY === void 0 ? 'middle' : _ref$anchorY,
      children = _ref.children,
      onSync = _ref.onSync,
      props = _objectWithoutPropertiesLoose__default['default'](_ref, ["anchorX", "anchorY", "children", "onSync"]);

  var _useThree = reactThreeFiber.useThree(),
      invalidate = _useThree.invalidate;

  var _useState = React.useState(function () {
    return new r3fTroika.Text();
  }),
      troikaMesh = _useState[0];

  var _useState2 = React.useState(),
      baseMtl = _useState2[0],
      setBaseMtl = _useState2[1];

  var _useMemo = React.useMemo(function () {
    var n = [];
    var t = '';
    React.Children.forEach(children, function (child, index) {
      if (typeof child === 'string') {
        t += child;
      } else if (child && typeof child === 'object' && child.props.attach === 'material') {
        // Instantiate the base material and grab a reference to it, but don't assign any
        // props, and assign it as the `material`, which Troika will replace behind the scenes.
        n.push( /*#__PURE__*/React.createElement(child.type, {
          ref: setBaseMtl,
          attach: 'material',
          key: index
        })); // Once the base material has been assigned, grab the resulting upgraded material,
        // and apply the original material props to that.

        if (baseMtl) {
          n.push( /*#__PURE__*/React__default['default'].createElement("primitive", _extends__default['default']({
            dispose: null,
            object: troikaMesh.material
          }, child.props, {
            key: "baseMtl:" + index,
            attach: null
          })));
        }
      } else {
        n.push(child);
      }
    });
    return [n, t];
  }, [children, baseMtl, troikaMesh.material]),
      nodes = _useMemo[0],
      text = _useMemo[1];

  React.useLayoutEffect(function () {
    return void troikaMesh.sync(function () {
      invalidate();
      if (onSync) onSync(troikaMesh);
    });
  });
  return /*#__PURE__*/React__default['default'].createElement("primitive", _extends__default['default']({
    dispose: null,
    object: troikaMesh,
    ref: ref,
    text: text,
    anchorX: anchorX,
    anchorY: anchorY
  }, props), nodes);
});

exports.Text = Text;
