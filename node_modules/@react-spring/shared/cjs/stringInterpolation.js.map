{"version":3,"file":"stringInterpolation.js","sourceRoot":"","sources":["../../src/stringInterpolation.ts"],"names":[],"mappings":";;;AAAA,iCAAsC;AACtC,2DAAyD;AAEzD,6CAA2C;AAC3C,6BAA8B;AAE9B,2DAA2D;AAC3D,mGAAmG;AACnG,IAAM,WAAW,GAAG,mDAAmD,CAAA;AAEvE,8BAA8B;AAC9B,qEAAqE;AACrE,IAAM,UAAU,GAAG,0FAA0F,CAAA;AAE7G,+CAA+C;AAC/C,IAAI,eAAuB,CAAA;AAE3B,0EAA0E;AAC1E,wDAAwD;AACxD,IAAM,SAAS,GAAG,8DAA8D,CAAA;AAChF,IAAM,SAAS,GAAG,UAAC,CAAM,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU;IACvE,OAAA,UAAQ,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,UAAK,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,UAAK,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,UAAK,EAAE,MAAG;AAAtE,CAAsE,CAAA;AAExE;;;;;;;;;GASG;AACU,QAAA,wBAAwB,GAAG,UACtC,MAAkC;IAElC,IAAI,CAAC,eAAe;QAClB,eAAe,GAAG,CAAC,CAAC,UAAU;YAC5B,CAAC,CAAC,IAAI,MAAM,CAAC,MAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,MAAG,EAAE,GAAG,CAAC;YAC7D,CAAC,CAAC,MAAM,CAAA,CAAC,cAAc;IAE3B,8BAA8B;IAC9B,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,UAAA,KAAK;QACpC,OAAA,sBAAa,CAAC,KAAK,CAAC;aACjB,OAAO,CAAC,UAAU,EAAE,yBAAW,CAAC;aAChC,OAAO,CAAC,eAAe,EAAE,yBAAW,CAAC;IAFxC,CAEwC,CACzC,CAAA;IAED,uDAAuD;IACvD,IAAM,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,KAAK,CAAC,WAAW,CAAE,CAAC,GAAG,CAAC,MAAM,CAAC,EAArC,CAAqC,CAAC,CAAA;IAE5E,uDAAuD;IACvD,IAAM,YAAY,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC;QACzC,OAAA,SAAS,CAAC,GAAG,CAAC,UAAA,MAAM;YAClB,IAAI,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,EAAE;gBAClB,MAAM,KAAK,CAAC,gDAAgD,CAAC,CAAA;aAC9D;YACD,OAAO,MAAM,CAAC,CAAC,CAAC,CAAA;QAClB,CAAC,CAAC;IALF,CAKE,CACH,CAAA;IAED,kDAAkD;IAClD,IAAM,aAAa,GAAG,YAAY,CAAC,GAAG,CAAC,UAAA,MAAM;QAC3C,OAAA,uCAAkB,uCAAM,MAAM,KAAE,MAAM,QAAA,IAAG;IAAzC,CAAyC,CAC1C,CAAA;IAED,qDAAqD;IACrD,OAAO,UAAC,KAAa;QACnB,IAAI,CAAC,GAAG,CAAC,CAAA;QACT,OAAO,MAAM,CAAC,CAAC,CAAC;aACb,OAAO,CAAC,WAAW,EAAE,cAAM,OAAA,MAAM,CAAC,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,EAAjC,CAAiC,CAAC;aAC7D,OAAO,CAAC,SAAS,EAAE,SAAS,CAAC,CAAA;IAClC,CAAC,CAAA;AACH,CAAC,CAAA","sourcesContent":["import { getFluidValue } from 'fluids'\nimport { createInterpolator } from './createInterpolator'\nimport { InterpolatorConfig } from './types'\nimport { colorToRgba } from './colorToRgba'\nimport * as G from './globals'\n\n// Problem: https://github.com/animatedjs/animated/pull/102\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\nconst numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g\n\n// Covers rgb, rgba, hsl, hsla\n// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e\nconst colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi\n\n// Covers color names (transparent, blue, etc.)\nlet colorNamesRegex: RegExp\n\n// rgba requires that the r,g,b are integers.... so we want to round them,\n// but we *dont* want to round the opacity (4th column).\nconst rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi\nconst rgbaRound = (_: any, p1: number, p2: number, p3: number, p4: number) =>\n  `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`\n\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *     \"rgba(123, 42, 99, 0.36)\"           // colors\n *     \"-45deg\"                            // values with units\n *     \"0 2px 2px 0px rgba(0, 0, 0, 0.12)\" // CSS box-shadows\n *     \"rotate(0deg) translate(2px, 3px)\"  // CSS transforms\n */\nexport const createStringInterpolator = (\n  config: InterpolatorConfig<string>\n) => {\n  if (!colorNamesRegex)\n    colorNamesRegex = G.colorNames\n      ? new RegExp(`(${Object.keys(G.colorNames).join('|')})`, 'g')\n      : /^\\b$/ // never match\n\n  // Convert colors to rgba(...)\n  const output = config.output.map(value =>\n    getFluidValue(value)\n      .replace(colorRegex, colorToRgba)\n      .replace(colorNamesRegex, colorToRgba)\n  )\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 2], [0, 0]]\n  const keyframes = output.map(value => value.match(numberRegex)!.map(Number))\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 0], [2, 0]]\n  const outputRanges = keyframes[0].map((_, i) =>\n    keyframes.map(values => {\n      if (!(i in values)) {\n        throw Error('The arity of each \"output\" value must be equal')\n      }\n      return values[i]\n    })\n  )\n\n  // Create an interpolator for each animated number\n  const interpolators = outputRanges.map(output =>\n    createInterpolator({ ...config, output })\n  )\n\n  // Use the first `output` as a template for each call\n  return (input: number) => {\n    let i = 0\n    return output[0]\n      .replace(numberRegex, () => String(interpolators[i++](input)))\n      .replace(rgbaRegex, rgbaRound)\n  }\n}\n"]}