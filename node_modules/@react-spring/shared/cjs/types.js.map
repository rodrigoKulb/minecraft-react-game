{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import { Arrify, Constrain } from './types.util'\n\n/** These types can be animated */\nexport type Animatable<T = any> = T extends number\n  ? number\n  : T extends string\n  ? string\n  : T extends ReadonlyArray<number | string>\n  ? Array<number | string> extends T // When true, T is not a tuple\n    ? ReadonlyArray<number | string>\n    : { [P in keyof T]: Animatable<T[P]> }\n  : never\n\nexport interface FrameRequestCallback {\n  (time?: number): void\n}\n\nexport type EasingFunction = (t: number) => number\n\nexport type ExtrapolateType = 'identity' | 'clamp' | 'extend'\n\nexport interface InterpolatorFactory {\n  <In, Out>(interpolator: InterpolatorFn<In, Out>): typeof interpolator\n\n  <Out>(config: InterpolatorConfig<Out>): (input: number) => Animatable<Out>\n\n  <Out>(\n    range: readonly number[],\n    output: readonly Constrain<Out, Animatable>[],\n    extrapolate?: ExtrapolateType\n  ): (input: number) => Animatable<Out>\n\n  <In, Out>(...args: InterpolatorArgs<In, Out>): InterpolatorFn<In, Out>\n}\n\nexport type InterpolatorArgs<In = any, Out = any> =\n  | [InterpolatorFn<Arrify<In>, Out>]\n  | [InterpolatorConfig<Out>]\n  | [\n      readonly number[],\n      readonly Constrain<Out, Animatable>[],\n      (ExtrapolateType | undefined)?\n    ]\n\nexport type InterpolatorFn<In, Out> = (...inputs: Arrify<In>) => Out\n\nexport type InterpolatorConfig<Out = Animatable> = {\n  /**\n   * What happens when the spring goes below its target value.\n   *\n   *  - `extend` continues the interpolation past the target value\n   *  - `clamp` limits the interpolation at the max value\n   *  - `identity` sets the value to the interpolation input as soon as it hits the boundary\n   *\n   * @default 'extend'\n   */\n  extrapolateLeft?: ExtrapolateType\n\n  /**\n   * What happens when the spring exceeds its target value.\n   *\n   *  - `extend` continues the interpolation past the target value\n   *  - `clamp` limits the interpolation at the max value\n   *  - `identity` sets the value to the interpolation input as soon as it hits the boundary\n   *\n   * @default 'extend'\n   */\n  extrapolateRight?: ExtrapolateType\n\n  /**\n   * What happens when the spring exceeds its target value.\n   * Shortcut to set `extrapolateLeft` and `extrapolateRight`.\n   *\n   *  - `extend` continues the interpolation past the target value\n   *  - `clamp` limits the interpolation at the max value\n   *  - `identity` sets the value to the interpolation input as soon as it hits the boundary\n   *\n   * @default 'extend'\n   */\n  extrapolate?: ExtrapolateType\n\n  /**\n   * Input ranges mapping the interpolation to the output values.\n   *\n   * @example\n   *\n   *   range: [0, 0.5, 1], output: ['yellow', 'orange', 'red']\n   *\n   * @default [0,1]\n   */\n  range?: readonly number[]\n\n  /**\n   * Output values from the interpolation function. Should match the length of the `range` array.\n   */\n  output: readonly Constrain<Out, Animatable>[]\n\n  /**\n   * Transformation to apply to the value before interpolation.\n   */\n  map?: (value: number) => number\n\n  /**\n   * Custom easing to apply in interpolator.\n   */\n  easing?: EasingFunction\n}\n"]}