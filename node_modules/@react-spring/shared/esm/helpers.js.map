{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../src/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Lookup, Arrify } from './types.util'\nimport * as G from './globals'\n\nexport const noop = () => {}\n\nexport const defineHidden = (obj: any, key: any, value: any) =>\n  Object.defineProperty(obj, key, { value, writable: true, configurable: true })\n\ninterface IsArray {\n  <T>(a: T): a is T & readonly any[]\n}\n\ntype PlainObject<T> = Exclude<T & Lookup, Function | readonly any[]>\n\nexport const is = {\n  arr: Array.isArray as IsArray,\n  obj: <T extends any>(a: T): a is PlainObject<T> =>\n    !!a && a.constructor.name === 'Object',\n  fun: (a: unknown): a is Function => typeof a === 'function',\n  str: (a: unknown): a is string => typeof a === 'string',\n  num: (a: unknown): a is number => typeof a === 'number',\n  und: (a: unknown): a is undefined => a === undefined,\n}\n\n/** Compare animatable values */\nexport function isEqual(a: any, b: any) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false\n    }\n    return true\n  }\n  return a === b\n}\n\n// Not all strings can be animated (eg: {display: \"none\"})\nexport const isAnimatedString = (value: unknown): value is string =>\n  is.str(value) &&\n  (value[0] == '#' ||\n    /\\d/.test(value) ||\n    !!(G.colorNames && G.colorNames[value]))\n\ntype Eachable<Value, Key> = {\n  forEach: (cb: (value: Value, key: Key) => void, ctx?: any) => void\n}\n\ntype InferKey<T extends object> = T extends Eachable<any, infer Key>\n  ? Key\n  : Extract<keyof T, string>\n\ntype InferValue<T extends object> = T extends\n  | Eachable<infer Value, any>\n  | { [key: string]: infer Value }\n  ? Value\n  : never\n\n/** An unsafe object/array/set iterator that allows for better minification */\nexport const each = <T extends object, This>(\n  obj: T & { forEach?: Function },\n  cb: (this: This, value: InferValue<T>, key: InferKey<T>) => void,\n  ctx?: This\n) => {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx)\n  } else {\n    Object.keys(obj).forEach(key =>\n      cb.call(ctx!, (obj as any)[key], key as any)\n    )\n  }\n}\n\nexport const toArray = <T>(a: T): Arrify<Exclude<T, void>> =>\n  is.und(a) ? [] : is.arr(a) ? (a as any) : [a]\n\n/** Copy the `queue`, then iterate it after the `queue` is cleared */\nexport function flush<P, T>(\n  queue: Map<P, T>,\n  iterator: (entry: [P, T]) => void\n): void\nexport function flush<T>(queue: Set<T>, iterator: (value: T) => void): void\nexport function flush(queue: any, iterator: any) {\n  if (queue.size) {\n    const items = Array.from(queue)\n    queue.clear()\n    each(items, iterator)\n  }\n}\n"]}